<!DOCTYPE html>
<html class="dark" lang="en">
<head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>Psycho-Engine Speedtest (HOLO Merge)</title>

  <link href="vendor/fonts/google-fonts.css" rel="stylesheet"/>
  <link href="holo-theme.css" rel="stylesheet"/>
  <script src="vendor/tailwind/tailwind.min.js"></script>

  <script id="tailwind-config">
    tailwind.config = {
      darkMode: "class",
      theme: {
        extend: {
          colors: {
            "primary": "#0db9f2",
            "secondary": "#a855f7",
            "background-dark": "#050a0c",
            "panel": "#111c21",
            "ethereal-blue": "#00d4ff",
            "cyber-violet": "#9d50bb",
            "void-black": "#020408",
            "engine-iron": "#1a1c23",
            "danger": "#ff3c00",
          },
          fontFamily: {
            "display": ["Space Grotesk", "sans-serif"],
            "mono": ["JetBrains Mono", "monospace"],
          },
          borderRadius: {
            "DEFAULT": "0.125rem",
            "lg": "0.25rem",
            "xl": "0.5rem",
            "full": "0.75rem"
          },
        },
      },
    };
  </script>

  <style type="text/tailwindcss">
    @layer utilities {
      .vhs-overlay {
        background:
          linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.18) 50%),
          linear-gradient(90deg, rgba(255,0,0,0.055), rgba(0,255,0,0.02), rgba(0,0,255,0.055));
        background-size: 100% 4px, 3px 100%;
        pointer-events: none;
      }
      .chromatic-aberration {
        text-shadow: 1.5px 0 0 rgba(255,0,0,0.38), -1.5px 0 0 rgba(0,255,255,0.38);
      }
      .glitch-border {
        box-shadow:
          0 0 14px rgba(0,212,255,0.20),
          0 0 30px rgba(157,80,187,0.12),
          inset 0 0 14px rgba(0,212,255,0.10);
      }
      .glass-ring {
        border: 2px solid rgba(0, 212, 255, 0.14);
        box-shadow:
          inset 0 0 20px rgba(0, 212, 255, 0.09),
          0 0 18px rgba(157, 80, 187, 0.16);
      }
      .nitro-shard {
        clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%);
      }
      .engine-frame {
        background: linear-gradient(145deg, #1a1c23, #020408);
        border: 1px solid rgba(255,255,255,0.05);
        box-shadow: 10px 10px 22px #010204, -5px -5px 15px rgba(255,255,255,0.02);
      }
      .neural-node {
        background: radial-gradient(circle, rgba(0, 212, 255, 0.30) 0%, transparent 70%);
      }
      .perspective-center { perspective: 1200px; }
      .rotate-x-25 { transform: rotateX(25deg); }
      .data-heart-glow { filter: drop-shadow(0 0 15px rgba(0,212,255,0.55)); }
      .soft-frost {
        background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
        backdrop-filter: blur(18px);
      }
      .scanline-mask {
        background-image: repeating-linear-gradient(
          0deg,
          rgba(255,255,255,0.00),
          rgba(255,255,255,0.00) 2px,
          rgba(0,212,255,0.08) 2px,
          rgba(0,212,255,0.08) 3px
        );
        mix-blend-mode: overlay;
      }
      .tap-glow:active { filter: drop-shadow(0 0 12px rgba(0,212,255,0.45)); }
      .tap-glow-low:active { filter: drop-shadow(0 0 6px rgba(0,212,255,0.25)); }
      .header-video-frame {
        background: linear-gradient(180deg, rgba(2,4,8,0.95), rgba(2,4,8,0.70), rgba(2,4,8,0.35), transparent);
        border-bottom: 1px solid rgba(255,255,255,0.06);
        box-shadow: 0 10px 30px rgba(0,0,0,0.6);
      }
    }
  </style>

  <style>
    body { min-height: max(884px, 100dvh); }

    @keyframes holoPulse {
      0%, 100% { transform: scale(1); filter: blur(28px); opacity: .28; }
      50% { transform: scale(1.06); filter: blur(34px); opacity: .38; }
    }
    @keyframes drift {
      0% { transform: translate3d(0,0,0); opacity: .35; }
      50% { transform: translate3d(10px,-8px,0); opacity: .55; }
      100% { transform: translate3d(0,0,0); opacity: .35; }
    }
    @keyframes jitter {
      0% { transform: translate3d(0,0,0); }
      15% { transform: translate3d(0.8px,-0.4px,0); }
      30% { transform: translate3d(-0.6px,0.6px,0); }
      45% { transform: translate3d(0.7px,0.2px,0); }
      60% { transform: translate3d(-0.4px,-0.5px,0); }
      75% { transform: translate3d(0.5px,0.6px,0); }
      100% { transform: translate3d(0,0,0); }
    }

    @keyframes gaugeSpectrum {
      0% { filter: hue-rotate(0deg) saturate(1.05); }
      50% { filter: hue-rotate(-18deg) saturate(1.4); }
      100% { filter: hue-rotate(0deg) saturate(1.05); }
    }

    @keyframes readoutFlicker {
      0%, 100% { text-shadow: 0 0 8px rgba(250,255,0,0.45), 0 0 20px rgba(250,255,0,0.2); }
      40% { text-shadow: 0 0 12px rgba(250,255,0,0.75), 0 0 28px rgba(255,0,255,0.24); }
      65% { text-shadow: 0 0 10px rgba(250,255,0,0.58), 0 0 24px rgba(0,212,255,0.2); }
    }

    @keyframes holoSweep {
      0% { transform: translateX(-120%) skewX(-20deg); opacity: 0; }
      22% { opacity: .55; }
      100% { transform: translateX(140%) skewX(-20deg); opacity: 0; }
    }

    @keyframes digitalShimmer {
      0%, 100% { opacity: .9; filter: brightness(1); }
      20% { opacity: .76; filter: brightness(1.08); }
      22% { opacity: .93; }
      56% { opacity: .84; filter: brightness(1.06); }
      82% { opacity: .95; }
    }

    .holo-gauge-shell {
      background: #000000;
      isolation: isolate;
      border-radius: 9999px;
      box-shadow: inset 0 0 40px rgba(0, 212, 255, 0.08), 0 0 30px rgba(0, 212, 255, 0.08);
      overflow: hidden;
    }

    .holo-gauge-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .holo-scan-sweep {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
    }

    .holo-scan-sweep::after {
      content: "";
      position: absolute;
      inset: -25%;
      background: linear-gradient(90deg, transparent 0%, rgba(0, 240, 255, 0.2) 40%, rgba(255, 255, 255, 0.38) 50%, rgba(0, 240, 255, 0.18) 60%, transparent 100%);
      animation: holoSweep 3.2s linear infinite;
    }

    .digital-shimmer {
      animation: digitalShimmer 1.35s steps(18, end) infinite;
    }

    .micro-metric {
      text-shadow: 0 0 8px rgba(0, 212, 255, 0.24);
    }

    .gauge-spectrum {
      animation: gaugeSpectrum 3.8s ease-in-out infinite;
      transform-origin: center;
    }

    .neon-yellow-readout {
      color: #b7ff00;
      animation: readoutFlicker 1.8s ease-in-out infinite;
    }

    /* Cyber button set (replaced with clipped cyber buttons) */

/* Cyberpunk clipped-glitch buttons (from attached style.css), adapted to this layout */
.cybr-btn {
  --primary: hsl(var(--primary-hue), 85%, calc(var(--primary-lightness, 50) * 1%));
  --shadow-primary: hsl(var(--shadow-primary-hue), 90%, 50%);
  --primary-hue: 180;
  --primary-lightness: 50;
  --color: hsl(0, 0%, 0%);
  --font-size: 14px;
  --shadow-primary-hue: 300;
  --shadow-secondary-hue: 60;
  --shadow-secondary: hsl(var(--shadow-secondary-hue), 90%, 60%);
  --clip: polygon(0 0, 100% 0, 100% 100%, 85% 100%, 8% 100%, 0 70%);
  --border: 4px;
  --shimmy-distance: 5;
  --clip-one: polygon(0 2%, 100% 2%, 100% 95%, 8% 95%, 0 70%);
  --clip-two: polygon(0 78%, 100% 78%, 100% 100%, 8% 100%, 0 78%);
  --clip-three: polygon(0 44%, 100% 44%, 100% 54%, 8% 54%, 0 54%);
  --clip-four: polygon(0 0, 100% 0, 100% 0, 8% 0, 0 0);
  --clip-five: polygon(0 0, 100% 0, 100% 0, 8% 0, 0 0);
  --clip-six: polygon(0 40%, 100% 40%, 100% 85%, 8% 85%, 0 70%);
  --clip-seven: polygon(0 63%, 100% 63%, 100% 80%, 8% 80%, 0 70%);

  position: relative;
  display: inline-flex;
  align-items: center;
  justify-content: center;

  width: 100%;
  height: 56px; /* keep existing size */
  padding: 0 16px;

  font-family: "Space Grotesk", sans-serif;
  font-style: italic; /* match the top header vibe */
  font-weight: 900;
  letter-spacing: 0.22em;
  text-transform: uppercase;
  font-size: var(--font-size);

  border: 0;
  outline: transparent;
  cursor: pointer;

  color: var(--color);
  background: transparent;
  transition: filter 0.2s, transform 0.12s;
  clip-path: var(--clip);
  -webkit-tap-highlight-color: transparent;
  user-select: none;
}

.cybr-btn:disabled {
  opacity: 0.55;
  cursor: not-allowed;
  filter: saturate(0.7);
}

.cybr-btn:active:not(:disabled) {
  transform: scale(0.985);
  filter: brightness(0.95);
}

.cybr-btn:before,
.cybr-btn:after {
  content: "";
  position: absolute;
  inset: 0;
  clip-path: var(--clip);
  z-index: -1;
}

.cybr-btn:before {
  background: var(--shadow-primary);
  transform: translate(var(--border), 0);
}

.cybr-btn:after {
  background: var(--primary);
}

.cybr-btn__glitch {
  position: absolute;
  top: calc(var(--border) * -1);
  left: calc(var(--border) * -1);
  right: calc(var(--border) * -1);
  bottom: calc(var(--border) * -1);
  background: var(--shadow-primary);
  text-shadow: 2px 2px var(--shadow-primary), -2px -2px var(--shadow-secondary);
  clip-path: var(--clip);
  animation: glitch 2s infinite;
  display: none;
  align-items: center;
  justify-content: center;
  font-family: "Space Grotesk", sans-serif;
  font-style: italic;
  font-weight: 900;
  letter-spacing: 0.22em;
  text-transform: uppercase;
  color: var(--color);
}

.cybr-btn:hover:not(:disabled) .cybr-btn__glitch {
  display: inline-flex;
}

.cybr-btn__glitch:before {
  content: "";
  position: absolute;
  inset: var(--border);
  clip-path: var(--clip);
  background: var(--primary);
  z-index: -1;
}

@keyframes glitch {
  0% { clip-path: var(--clip-one); }
  2%, 8% { clip-path: var(--clip-two); transform: translate(calc(var(--shimmy-distance) * -1%), 0); }
  6% { clip-path: var(--clip-two); transform: translate(calc(var(--shimmy-distance) * 1%), 0); }
  9% { clip-path: var(--clip-two); transform: translate(0, 0); }
  10% { clip-path: var(--clip-three); transform: translate(calc(var(--shimmy-distance) * 1%), 0); }
  13% { clip-path: var(--clip-three); transform: translate(0, 0); }
  14%, 21% { clip-path: var(--clip-four); transform: translate(calc(var(--shimmy-distance) * 1%), 0); }
  25% { clip-path: var(--clip-five); transform: translate(calc(var(--shimmy-distance) * 1%), 0); }
  30% { clip-path: var(--clip-five); transform: translate(calc(var(--shimmy-distance) * -1%), 0); }
  35%, 45% { clip-path: var(--clip-six); transform: translate(calc(var(--shimmy-distance) * -1%)); }
  40% { clip-path: var(--clip-six); transform: translate(calc(var(--shimmy-distance) * 1%)); }
  50% { clip-path: var(--clip-six); transform: translate(0, 0); }
  55% { clip-path: var(--clip-seven); transform: translate(calc(var(--shimmy-distance) * 1%), 0); }
  60% { clip-path: var(--clip-seven); transform: translate(0, 0); }
  31%, 61%, 100% { clip-path: var(--clip-four); }
}

/* Color variants: green engage, pink abort, violet reset */
.cybr-green { --primary-hue: 135; --shadow-primary-hue: 150; --shadow-secondary-hue: 60; --primary-lightness: 58; }
.cybr-pink  { --primary-hue: 315; --shadow-primary-hue: 320; --shadow-secondary-hue: 180; --primary-lightness: 60; }
.cybr-violet{ --primary-hue: 275; --shadow-primary-hue: 285; --shadow-secondary-hue: 180; --primary-lightness: 58; }

@media (prefers-reduced-motion: reduce) {
      * { animation-duration: 0.001ms !important; animation-iteration-count: 1 !important; transition-duration: 0.001ms !important; scroll-behavior: auto !important; }
    }
    /* === Config screen controls styling === */
    .toggle {
      -webkit-appearance: none;
      appearance: none;
      width: 3rem;
      height: 1.4rem;
      background-color: rgba(255,255,255,0.05);
      border: 1px solid var(--toggle-border, #00d4ff);
      border-radius: 9999px;
      position: relative;
      cursor: pointer;
      outline: none;
      transition: background-color 0.3s, border-color 0.3s;
    }
    .toggle::after {
      content: "";
      position: absolute;
      top: 0.1rem;
      left: 0.1rem;
      width: 1.2rem;
      height: 1.2rem;
      background-color: var(--toggle-knob, #00d4ff);
      border-radius: 9999px;
      transition: transform 0.3s, background-color 0.3s;
      box-shadow: 0 0 6px var(--toggle-knob, #00d4ff);
    }
    .toggle:checked {
      background-color: rgba(157,80,187,0.3);
      border-color: #9d50bb;
    }
    .toggle:checked::after {
      transform: translateX(1.6rem);
      background-color: #9d50bb;
      box-shadow: 0 0 6px #9d50bb;
    }
    /* Range slider styling */
    input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      background: transparent;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      height: 4px;
      background: rgba(0,212,255,0.3);
      border-radius: 2px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: #00d4ff;
      border-radius: 50%;
      margin-top: -5px;
      box-shadow: 0 0 6px #00d4ff;
    }
    input[type="range"]::-moz-range-track {
      height: 4px;
      background: rgba(0,212,255,0.3);
      border-radius: 2px;
    }
    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: #00d4ff;
      border-radius: 50%;
      border: none;
      box-shadow: 0 0 6px #00d4ff;
    }
    /* Neon button style */
    :root {
      --neon-yellow-green: #b7ff00;
      --neon-yellow-green-glow: rgba(183, 255, 0, 0.56);
    }
    .btn-neon {
      position: relative;
      padding: 0.6rem 1.2rem;
      font-size: 0.8rem;
      font-weight: 900;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      border: 2px solid currentColor;
      border-radius: 0.375rem;
      color: var(--btn-color, #00d4ff);
      background: linear-gradient(140deg, rgba(4, 4, 4, 0.95), rgba(12, 4, 16, 0.92));
      overflow: hidden;
      transition: color 0.3s, transform 0.16s ease;
      font-family: "Orbitron", sans-serif;
      text-shadow: 0 0 8px color-mix(in srgb, var(--btn-color, #00d4ff) 60%, transparent);
      animation: navFlux 2.8s ease-in-out infinite;
    }
    .btn-neon::before {
      content: "";
      position: absolute;
      inset: 0;
      background: var(--btn-glow, rgba(0,212,255,0.3));
      opacity: 0;
      transition: opacity 0.3s;
      z-index: -1;
      filter: blur(8px);
    }
    .btn-neon:hover {
      color: #000;
      transform: translateY(-1px) scale(1.02);
    }
    .btn-neon:hover::before {
      opacity: 1;
    }

    /* Additional animations and holographic device styles */
    /* Rotate animations for spinning rings around the WiFi symbol */
    @keyframes revolve {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    @keyframes revolve-reverse {
      from { transform: rotate(360deg); }
      to { transform: rotate(0deg); }
    }
    .spin-slow {
      animation: revolve 30s linear infinite;
    }
    .spin-slower {
      animation: revolve-reverse 50s linear infinite;
    }
    /* Electrify effect for icons */
    @keyframes electrify {
      0%, 100% {
        filter: drop-shadow(0 0 2px var(--glow-color)) brightness(1);
      }
      50% {
        filter: drop-shadow(0 0 8px var(--glow-color)) brightness(1.4);
      }
    }
    .electrify {
      animation: electrify 2s infinite;
    }
    /* Device card styles */
    .shard-card {
      background: rgba(0, 0, 0, 0.96);
      backdrop-filter: blur(6px);
      border: 1px solid rgba(0, 212, 255, 0.2);
      transform-style: preserve-3d;
      transition: transform 0.24s ease, border-color 0.24s ease, box-shadow 0.24s ease;
      position: relative;
      overflow: hidden;
      clip-path: polygon(12px 0, 100% 0, 100% calc(100% - 14px), calc(100% - 14px) 100%, 0 100%, 0 14px);
      contain: content;
      touch-action: pan-y;
    }
    .shard-card::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, transparent 40%, transparent 60%, rgba(0, 0, 0, 0.4) 100%);
      z-index: -1;
      pointer-events: none;
    }
    .shard-card::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 2px;
      padding: 1px;
      background: linear-gradient(45deg, transparent, var(--edge-color, #00ff9d), transparent);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      opacity: 0.55;
      pointer-events: none;
    }
    .shard-card:hover {
      transform: translateY(-1px);
      border-color: color-mix(in srgb, var(--edge-color, #00d4ff) 60%, #ffffff 40%);
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--edge-color, #00d4ff) 42%, transparent);
      z-index: 10;
    }
    .shard-card:active {
      border-color: color-mix(in srgb, var(--edge-color, #00d4ff) 80%, #ffffff 20%);
      box-shadow: 0 0 0 1px color-mix(in srgb, var(--edge-color, #00d4ff) 78%, transparent), 0 0 18px var(--glow-color, rgba(0, 212, 255, 0.32));
      z-index: 10;
    }
    .device-rim-icon {
      border: 1px solid color-mix(in srgb, var(--edge-color, #00d4ff) 40%, transparent);
      background: radial-gradient(circle at 35% 30%, rgba(255,255,255,0.14), transparent 55%), rgba(0, 8, 14, 0.92);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.04), 0 0 14px color-mix(in srgb, var(--edge-color, #00d4ff) 18%, transparent);
    }
    .holo-meter-track {
      height: 6px;
      border-radius: 99px;
      background: linear-gradient(90deg, rgba(0, 212, 255, 0.08), rgba(157, 80, 187, 0.22));
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.14);
    }
    .holo-meter-fill {
      height: 100%;
      border-radius: inherit;
      background: linear-gradient(90deg, color-mix(in srgb, var(--edge-color, #00d4ff) 65%, #9d50bb 35%), #d6ffff);
      box-shadow: 0 0 8px color-mix(in srgb, var(--edge-color, #00d4ff) 25%, transparent);
    }
    .signal-pulse {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--edge-color, #00d4ff);
      box-shadow: 0 0 10px color-mix(in srgb, var(--edge-color, #00d4ff) 35%, transparent);
      animation: pulseBeacon 1.8s ease-in-out infinite;
    }
    @keyframes pulseBeacon {
      0%, 100% { transform: scale(0.82); opacity: 0.58; }
      50% { transform: scale(1); opacity: 0.95; }
    }
    .holo-state-card {
      background: linear-gradient(130deg, rgba(0, 10, 16, 0.95), rgba(2, 4, 8, 0.98));
      border: 1px solid rgba(0,212,255,0.25);
      box-shadow: inset 0 0 28px rgba(0,212,255,0.04);
    }
    .liquid-bar-container {
      background: rgba(0, 0, 0, 0.8);
      border-radius: 4px;
      box-shadow: inset 1px 1px 3px rgba(0, 0, 0, 0.8), inset -1px -1px 2px rgba(255, 255, 255, 0.1);
      position: relative;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .liquid-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--bar-start) 0%, var(--bar-mid) 50%, var(--bar-end) 100%);
      position: relative;
      box-shadow: 0 0 10px var(--bar-mid);
    }
    .liquid-bar-fill::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(to bottom, rgba(255, 255, 255, 0.4), transparent);
    }
    .model-cube {
      width: 40px;
      height: 40px;
      position: relative;
      transform-style: preserve-3d;
      animation: cube-spin 8s linear infinite;
    }
    .cube-face {
      position: absolute;
      width: 40px;
      height: 40px;
      border: 1px solid var(--model-color);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .cube-face.front { transform: rotateY(0deg) translateZ(20px); }
    .cube-face.back { transform: rotateY(180deg) translateZ(20px); }
    .cube-face.right { transform: rotateY(90deg) translateZ(20px); }
    .cube-face.left { transform: rotateY(-90deg) translateZ(20px); }
    .cube-face.top { transform: rotateX(90deg) translateZ(20px); }
    .cube-face.bottom { transform: rotateX(-90deg) translateZ(20px); }
    @keyframes cube-spin {
      0% { transform: rotateX(-15deg) rotateY(0deg); }
      100% { transform: rotateX(-15deg) rotateY(360deg); }
    }
    .shadow-neon { box-shadow: 0 0 5px #00ff9d, 0 0 15px #00ff9d; }
    .shadow-neon-cyan { box-shadow: 0 0 5px #00f3ff, 0 0 15px #00f3ff; }
    .shadow-neon-orange { box-shadow: 0 0 10px #ffaa00, 0 0 25px #ffaa00; }
    .shadow-purple { box-shadow: 0 0 10px #a855f7, 0 0 20px #a855f7; }

    /* Additional HUD classes from Wifi_map for map screen */
    .glitch-text {
      text-shadow: 2px 0 #00d4ff, -2px 0 #9d50bb;
      letter-spacing: -0.05em;
    }
    .shard-clip {
      clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%);
    }
    .shard-clip-alt {
      clip-path: polygon(0 15%, 95% 0, 100% 85%, 5% 100%);
    }
    .radar-ring {
      border: 1px solid rgba(0, 212, 255, 0.3);
      border-radius: 50%;
      position: absolute;
    }
    .lightning-line {
      background: linear-gradient(90deg, transparent, #00d4ff, transparent);
      height: 1px;
      filter: blur(1px);
    }
    /* Wireframe and digital rain overlays used in the WiFi map screen */
    .wireframe-bg {
      background-image:
        linear-gradient(to right, rgba(0, 212, 255, 0.05) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(0, 212, 255, 0.05) 1px, transparent 1px);
      background-size: 20px 20px;
    }
    .digital-rain-overlay {
      background: linear-gradient(180deg, rgba(0,212,255,0) 0%, rgba(0,212,255,0.05) 50%, rgba(0,212,255,0) 100%);
      background-size: 100% 200%;
    }
    /* Triangular shard clipping used for the overdrive/cloak buttons from wifi_map */
    .shard-clip {
      clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%);
    }
    .shard-clip-alt {
      clip-path: polygon(0 15%, 95% 0, 100% 85%, 5% 100%);
    }
    /* Conic gradient used for the engine gauge to restore the missing blue and red arcs. The mask ensures the center remains transparent. */
    .gauge-conic {
      background: conic-gradient(from 225deg, transparent 0deg, #00d4ff 40deg, #00d4ff 180deg, #ff3c00 240deg, transparent 270deg);
      mask: radial-gradient(transparent 65%, black 66%);
      -webkit-mask: radial-gradient(transparent 65%, black 66%);
    }
    /* Neon glow for WiFi list cards and headings */
    .neon-glow {
      text-shadow: 0 0 8px rgba(0, 212, 255, 0.6);
    }
    /* Slight flicker effect for bars in the WiFi list */
    .flicker {
      opacity: 0.8;
    }
    /* Frosted glass panel effect used in WiFi list overlays and cards */
    .glass-panel {
      background: rgba(0, 212, 255, 0.03);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(0, 212, 255, 0.2);
    }
    .app-nav {
      background: linear-gradient(180deg, rgba(1, 1, 1, 0.96), rgba(8, 3, 10, 0.95));
      backdrop-filter: blur(18px);
      border-top: 1px solid rgba(255, 0, 221, 0.35);
      box-shadow: 0 -8px 24px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(250, 255, 0, 0.24);
    }
    .italic-heavy {
      font-style: italic;
      font-weight: 800;
      transform: skewX(-5deg);
    }
    .nav-tab {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 2px 0;
      color: #66e8ff;
      transition: color 0.16s ease, transform 0.16s ease, text-shadow 0.16s ease;
      font-family: "Orbitron", "Space Grotesk", sans-serif;
      font-weight: 900;
      letter-spacing: 0.07em;
      text-shadow: 0 0 8px rgba(0, 212, 255, 0.35);
    }
    .nav-tab .material-symbols-outlined {
      font-size: 24px;
      font-variation-settings: "FILL" 0;
    }
    .nav-tab .nav-icon-word {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      font-family: "Orbitron", "Space Grotesk", sans-serif;
      font-style: italic;
      font-weight: 900;
      line-height: 1;
    }
    .nav-tab .tab-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }
    .nav-tab:hover {
      color: var(--neon-yellow-green);
      text-shadow: 0 0 12px var(--neon-yellow-green-glow);
    }
    .nav-tab.is-active {
      color: #ff33df;
      text-shadow: 0 0 16px rgba(255, 51, 223, 0.68), 0 0 8px rgba(250,255,0,0.35);
    }
    .nav-tab.is-active .material-symbols-outlined {
      font-variation-settings: "FILL" 1;
    }
    .nav-tab:active {
      transform: scale(0.96);
    }
    .nav-tab .tab-label,
    .nav-tab .material-symbols-outlined,
    .nav-tab .nav-icon-word {
      animation: navFlux 2.4s ease-in-out infinite;
    }
    .nav-emoji {
      font-size: 14px;
      line-height: 1;
    }
    .holo-center-intel {
      position: relative;
      width: min(86%, 260px);
      border: 1px solid color-mix(in srgb, var(--neon-yellow-green) 80%, transparent);
      background: linear-gradient(145deg, rgba(0, 8, 12, 0.86), rgba(10, 3, 14, 0.88));
      border-radius: 14px;
      box-shadow: inset 0 0 18px rgba(0, 212, 255, 0.16), 0 0 16px rgba(255, 0, 221, 0.2);
      overflow: hidden;
      padding: 10px;
    }
    .holo-center-intel::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, transparent 0%, color-mix(in srgb, var(--neon-yellow-green) 28%, transparent) 48%, transparent 100%);
      mix-blend-mode: screen;
      animation: sparkFlow 3s linear infinite;
      pointer-events: none;
    }
    .holo-center-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }
    .holo-center-cell {
      border: 1px solid rgba(255, 51, 223, 0.28);
      border-radius: 8px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.72);
    }
    .holo-center-label {
      font-family: "Orbitron", sans-serif;
      font-size: 8px;
      letter-spacing: 0.2em;
      color: color-mix(in srgb, var(--neon-yellow-green) 86%, white 14%);
      text-transform: uppercase;
    }
    .holo-center-value {
      font-family: "Orbitron", sans-serif;
      font-size: 16px;
      font-weight: 900;
      letter-spacing: 0.08em;
      color: #66e8ff;
      text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
      margin-top: 3px;
      display: block;
    }
    .holo-center-value.warn {
      color: var(--neon-yellow-green);
      text-shadow: 0 0 10px var(--neon-yellow-green-glow);
    }
    .holo-center-value.hot {
      color: #ff33df;
      text-shadow: 0 0 10px rgba(255, 51, 223, 0.5);
    }
    .electric-aura {
      position: absolute;
      width: 76%;
      height: 76%;
      border-radius: 9999px;
      background: radial-gradient(circle, rgba(0, 224, 255, 0.25) 0%, rgba(250, 255, 0, 0.18) 36%, rgba(2,4,8,0) 70%);
      filter: blur(9px);
      animation: holoPulse 2.6s ease-in-out infinite;
    }
    .map-node-dot {
      box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
    }
    .holo-map-viewport {
      touch-action: none;
      background: #000000;
      cursor: grab;
    }
    .holo-map-viewport.is-panning {
      cursor: grabbing;
    }
    .holo-map-node-tooltip {
      position: absolute;
      z-index: 35;
      min-width: 130px;
      max-width: 220px;
      padding: 8px 10px;
      border: 1px solid rgba(0, 212, 255, 0.55);
      background: rgba(0, 0, 0, 0.82);
      color: #c8f7ff;
      font-size: 10px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      pointer-events: none;
      backdrop-filter: blur(4px);
      box-shadow: 0 0 16px rgba(0, 212, 255, 0.28);
      transform: translate(-50%, calc(-100% - 14px));
      opacity: 0;
      transition: opacity 120ms linear;
    }
    .holo-map-node-tooltip.is-visible {
      opacity: 1;
    }
    @keyframes sparkFlow {
      0% { background-position: 0% 50%; }
      100% { background-position: 100% 50%; }
    }
    @keyframes navFlux {
      0%, 100% { filter: brightness(1) saturate(1); }
      50% { filter: brightness(1.16) saturate(1.3); }
    }
    @keyframes memoryPulse {
      0%, 100% { box-shadow: 0 0 0 1px rgba(255, 0, 221, 0.34), 0 0 12px rgba(0, 212, 255, 0.2); }
      50% { box-shadow: 0 0 0 1px var(--neon-yellow-green-glow), 0 0 20px rgba(255, 0, 221, 0.35); }
    }
    .wifi-list-screen,
    .wifi-list-screen *:not(.material-symbols-outlined) {
      font-family: "Orbitron", "Space Grotesk", sans-serif;
    }
    .memory-pulse {
      animation: memoryPulse 2.2s ease-in-out infinite;
    }
    .memory-word {
      font-size: 9px;
      letter-spacing: 0.16em;
      font-family: "Orbitron", "Space Grotesk", sans-serif;
      font-style: italic;
      font-weight: 900;
      text-transform: uppercase;
      line-height: 1;
    }
  </style>
</head>

<body class="bg-black font-display text-slate-100 overflow-y-auto antialiased">
  <div class="fixed inset-0 vhs-overlay z-50 mix-blend-overlay opacity-30 pointer-events-none"></div>

  <div class="fixed inset-0 z-0 overflow-hidden pointer-events-none holo-layer" id="holoParticleField">
    <div class="absolute top-[15%] left-[20%] w-1.5 h-1.5 neural-node rounded-full blur-[2px] opacity-40" style="animation: drift 7s ease-in-out infinite;"></div>
    <div class="absolute top-[40%] right-[10%] w-1 h-1 neural-node rounded-full blur-[1px] opacity-60" style="animation: drift 9s ease-in-out infinite;"></div>
    <div class="absolute bottom-[30%] left-[15%] w-2 h-2 neural-node rounded-full blur-[3px] opacity-30" style="animation: drift 11s ease-in-out infinite;"></div>
    <div class="absolute top-[70%] right-[30%] w-1 h-1 neural-node rounded-full blur-[1px] opacity-50" style="animation: drift 8s ease-in-out infinite;"></div>
    <div class="absolute top-[25%] right-[45%] w-1.5 h-1.5 neural-node rounded-full blur-[2px] opacity-35" style="animation: drift 10s ease-in-out infinite;"></div>
    <div class="absolute bottom-[18%] right-[18%] w-2 h-2 neural-node rounded-full blur-[3px] opacity-22" style="animation: drift 12s ease-in-out infinite;"></div>
    <div class="absolute top-[58%] left-[8%] w-1 h-1 neural-node rounded-full blur-[1px] opacity-55" style="animation: drift 6s ease-in-out infinite;"></div>

    <div class="absolute inset-0 bg-[radial-gradient(circle_at_center,rgba(0,212,255,0.08)_0%,rgba(2,4,8,0.00)_55%,rgba(2,4,8,0.90)_78%)]"></div>
    <div class="absolute inset-0 bg-gradient-to-b from-transparent via-void-black to-void-black"></div>
  </div>

  <!-- WiFi List screen -->
  <section id="wifiListScreen" class="wifi-list-screen hidden relative flex min-h-[100dvh] w-full flex-col items-center bg-black text-slate-100 overflow-y-auto holo-layer holo-scanlines">
    <!-- Header -->
    <div class="w-full border-b border-ethereal-blue/10 bg-void-black/80 backdrop-blur-md p-4 sm:p-6 flex items-center justify-between">
      <div class="flex items-center gap-2">
        <span class="material-symbols-outlined text-ethereal-blue text-xl sm:text-2xl">wifi</span>
        <div class="flex flex-col">
          <span class="text-[10px] sm:text-[10px] font-black tracking-[0.42em] uppercase" style="font-family:'Orbitron',sans-serif; color:var(--neon-yellow-green); animation:navFlux 2.1s ease-in-out infinite;">DEVICE_MATRIX</span>
          <h2 class="text-sm sm:text-lg font-black leading-tight tracking-[0.08em] uppercase" style="font-family:'Orbitron',sans-serif; color:#ff00ff;">NEURAL_DEVICE_SCANNER</h2>
        </div>
      </div>
      <button class="tap-glow memory-pulse size-12 rounded-full bg-[#ff00dd]/10 border border-[#ff00dd]/45 flex flex-col items-center justify-center text-[var(--neon-yellow-green)]" type="button" aria-label="Memory telemetry">
        <span class="memory-word">MEMORY</span>
        <span class="text-[7px] leading-none tracking-[0.2em] uppercase">mem</span>
      </button>
    </div>
    <h4 class="text-[9px] sm:text-[10px] font-black leading-normal tracking-[0.34em] px-4 py-2 text-center uppercase" style="font-family:'Orbitron',sans-serif; color:var(--neon-yellow-green); animation:navFlux 2.2s ease-in-out infinite;">DEVICE_MATRIX_ONLINE</h4>
    <!-- Central Hologram -->
    <div class="relative w-full flex justify-center p-4">
      <div class="relative w-64 h-64 sm:w-72 sm:h-72 flex items-center justify-center overflow-hidden">
        <div class="absolute inset-0 opacity-10" style="background-image: radial-gradient(circle, #00d4ff 1px, transparent 1px); background-size: 20px 20px;"></div>
        <div class="absolute inset-0 bg-ethereal-blue/10 rounded-full blur-3xl animate-pulse"></div>
        <div class="electric-aura" aria-hidden="true"></div>
        <div class="relative z-10 flex items-center justify-center">
          <div class="holo-center-intel" aria-label="Live scan telemetry">
            <div class="holo-center-grid">
              <div class="holo-center-cell">
                <span class="holo-center-label">Targets</span>
                <span id="wifiIntelCount" class="holo-center-value">0</span>
              </div>
              <div class="holo-center-cell">
                <span class="holo-center-label">Strongest</span>
                <span id="wifiIntelSignal" class="holo-center-value warn">-- dBm</span>
              </div>
              <div class="holo-center-cell">
                <span class="holo-center-label">Band</span>
                <span id="wifiIntelBand" class="holo-center-value">-- MHz</span>
              </div>
              <div class="holo-center-cell">
                <span class="holo-center-label">Status</span>
                <span id="wifiIntelStatus" class="holo-center-value hot">STBY</span>
              </div>
            </div>
          </div>
        </div>
        <!-- Spinning Neon Square Frames -->
        <!-- Outer square frame uses the same slow spin animation as the engine gauge and is colored neon yellow -->
        <div class="absolute inset-0 border border-yellow-400 border-dashed spin-slow opacity-70" style="border-color:var(--neon-yellow-green);"></div>
        <!-- Inner square frame inset to provide depth and rotates in the opposite direction for a parallax effect -->
        <div class="absolute inset-[10%] border border-yellow-400 border-dashed spin-slower opacity-40" style="border-color:var(--neon-yellow-green);"></div>
      </div>
      <!-- Overlay Data -->
      <div class="absolute top-6 left-4 glass-panel p-2 rounded text-[9px] sm:text-[10px] font-mono italic" style="color:color-mix(in srgb, var(--neon-yellow-green) 88%, white 12%);">
        LAT: 37.7749<br/>LNG: -122.4194
      </div>
      <div class="absolute bottom-4 right-4 glass-panel p-2 rounded text-[9px] sm:text-[10px] text-[#ff33df] font-mono flicker">
        PACKETS: 1.2k/s<br/>DROPPED: 0.02%
      </div>
    </div>
    <!-- Scan header -->
    <div class="w-full px-4 py-3 flex flex-col gap-3 border-b border-ethereal-blue/20">
      <div class="flex items-end justify-between gap-4">
        <div class="flex flex-col">
          <h3 class="text-[#ff33df] text-xs sm:text-sm font-black leading-tight tracking-[0.18em] uppercase" style="font-family:'Orbitron',sans-serif;">Nearby_SSIDs_Scan</h3>
          <span id="wifiScanMeta" class="text-[9px] sm:text-[10px] font-mono" style="color:color-mix(in srgb, var(--neon-yellow-green) 74%, white 26%);">Waiting for live scan data</span>
        </div>
        <div class="flex flex-wrap justify-end gap-2">
          <button id="wifiScanBtn" class="btn-neon" style="--btn-color:#ff33df; --btn-glow:rgba(255,51,223,0.34)">⚡ Scan</button>
          <button id="wifiExportBtn" class="btn-neon" style="--btn-color:var(--neon-yellow-green); --btn-glow:var(--neon-yellow-green-glow)">📤 Export</button>
        </div>
      </div>
      <div class="grid grid-cols-1 sm:grid-cols-3 gap-2">
        <div class="soft-frost border border-[#ff33df]/30 rounded-lg px-3 py-2">
          <div class="text-[9px] uppercase tracking-[0.3em] font-mono" style="color:color-mix(in srgb, var(--neon-yellow-green) 82%, white 18%);">Bridge</div>
          <div id="wifiBridgeState" class="text-xs font-bold text-[#ff33df] mt-1">Offline</div>
        </div>
        <div class="soft-frost border border-[#00d4ff]/30 rounded-lg px-3 py-2">
          <div class="text-[9px] uppercase tracking-[0.3em] text-[#00d4ff]/80 font-mono">Permissions</div>
          <div id="wifiPermissionState" class="text-xs font-bold text-[#00d4ff] mt-1">Tap Scan To Grant</div>
        </div>
        <div class="soft-frost border rounded-lg px-3 py-2" style="border-color:color-mix(in srgb, var(--neon-yellow-green) 38%, transparent);">
          <div class="text-[9px] uppercase tracking-[0.3em] text-[#ff33df]/85 font-mono">Scanner</div>
          <div id="wifiScanState" class="text-xs font-bold mt-1" style="color:var(--neon-yellow-green);">Standby</div>
        </div>
      </div>
    </div>
    <div id="wifiEmptyState" class="w-full px-4 pt-5">
      <div class="holo-state-card rounded-xl px-4 py-4 text-center">
        <div id="wifiStateBadge" class="text-[9px] tracking-[0.34em] uppercase text-ethereal-blue/70 font-black" style="font-family:'Orbitron',sans-serif;">STANDBY</div>
        <div id="wifiStateMessage" class="mt-2 text-[11px] tracking-[0.2em] uppercase text-ethereal-blue/55 font-mono">No networks loaded. Tap Scan for live discovery.</div>
      </div>
    </div>
    <div id="wifiDeviceList" class="flex flex-col w-full px-4 py-4 gap-4 overflow-y-auto"></div>
  </section>

  <!-- Configuration Screen -->
  <section id="configScreen" class="hidden relative flex min-h-[100dvh] w-full flex-col bg-black text-slate-100 overflow-y-auto holo-layer holo-scanlines">
    <!-- Config header -->
    <div class="w-full border-b border-ethereal-blue/10 bg-void-black/80 backdrop-blur-md p-4 sm:p-6 flex items-center justify-between">
      <div class="flex items-center gap-2">
        <span class="material-symbols-outlined text-ethereal-blue text-xl sm:text-2xl">settings</span>
        <h2 class="text-ethereal-blue text-sm sm:text-lg font-bold leading-tight tracking-tight italic">System Configuration</h2>
      </div>
    </div>
    <div class="w-full max-w-md mx-auto px-4 sm:px-6 py-6 flex flex-col space-y-6">
      <!-- Toggle settings -->
      <div class="space-y-4">
        <label class="flex items-center justify-between">
          <span class="text-sm text-ethereal-blue font-mono uppercase">Auto Scan</span>
          <input id="cfgAutoScan" type="checkbox" class="toggle" />
        </label>
        <label class="flex items-center justify-between">
          <span class="text-sm text-ethereal-blue font-mono uppercase">Holo FX</span>
          <input id="cfgHoloFX" type="checkbox" class="toggle" />
        </label>
        <label class="flex items-center justify-between">
          <span class="text-sm text-ethereal-blue font-mono uppercase">Alerts</span>
          <input id="cfgAlerts" type="checkbox" class="toggle" />
        </label>
        <label class="flex items-center justify-between">
          <span class="text-sm text-ethereal-blue font-mono uppercase">Fallback Mode (Disabled)</span>
          <input id="cfgDemoMode" type="checkbox" class="toggle" />
        </label>
        <label class="flex items-center justify-between">
          <span class="text-sm text-ethereal-blue font-mono uppercase">Native Bridge</span>
          <input id="cfgBridgeEnabled" type="checkbox" class="toggle" />
        </label>
      </div>
      <!-- Slider settings -->
      <div class="space-y-4">
        <label class="flex flex-col gap-1">
          <span class="text-sm text-ethereal-blue font-mono uppercase">Neon Intensity</span>
          <input id="cfgNeonIntensity" type="range" min="0" max="100" value="70" />
        </label>
        <label class="flex flex-col gap-1">
          <span class="text-sm text-ethereal-blue font-mono uppercase">Scan Speed</span>
          <input id="cfgScanSpeed" type="range" min="0" max="100" value="50" />
        </label>
      </div>
      <!-- Accent mode selector -->
      <div class="flex flex-col gap-1">
        <span class="text-sm text-ethereal-blue font-mono uppercase">Accent Mode</span>
        <select id="cfgAccentMode" class="bg-void-black border border-ethereal-blue/30 text-ethereal-blue text-sm p-2 rounded focus:outline-none">
          <option value="blue">Blue</option>
          <option value="violet">Violet</option>
          <option value="pink">Pink</option>
          <option value="green">Green</option>
        </select>
      </div>
      <!-- Performance mode selector -->
      <div class="flex flex-col gap-1">
        <span class="text-sm text-ethereal-blue font-mono uppercase">Performance Mode</span>
        <select id="cfgPerfMode" class="bg-void-black border border-ethereal-blue/30 text-ethereal-blue text-sm p-2 rounded focus:outline-none">
          <option value="high">High FX</option>
          <option value="low">Low FX</option>
        </select>
      </div>
      <!-- Buttons -->
      <div class="flex justify-start gap-4 pt-4">
        <button id="cfgSaveBtn" class="btn-neon" style="--btn-color:#00d4ff; --btn-glow:rgba(0,212,255,0.3)">💾 Save</button>
        <button id="cfgResetBtn" class="btn-neon" style="--btn-color:#ff3c00; --btn-glow:rgba(255,60,0,0.3)">♻️ Reset</button>
      </div>
      <div class="space-y-3 border border-ethereal-blue/20 rounded-lg p-4 soft-frost">
        <div>
          <div class="text-[10px] uppercase tracking-[0.3em] text-ethereal-blue/60 font-mono">Bridge State</div>
          <div id="cfgBridgeSummary" class="text-sm text-ethereal-blue mt-1">Checking native layer...</div>
        </div>
        <div>
          <div class="text-[10px] uppercase tracking-[0.3em] text-ethereal-blue/60 font-mono">Device Info</div>
          <div id="cfgDeviceSummary" class="text-sm text-slate-300 mt-1">No device snapshot yet.</div>
        </div>
        <div class="flex flex-wrap gap-3 pt-1">
          <button id="cfgRefreshDeviceBtn" class="btn-neon" style="--btn-color:#00ff9d; --btn-glow:rgba(0,255,157,0.3)">🧠 Refresh Device</button>
          <button id="cfgExportDiagBtn" class="btn-neon" style="--btn-color:#b7ff00; --btn-glow:rgba(250,255,0,0.3)">🛰️ Export Diag</button>
        </div>
      </div>
      <p id="cfgStatusMsg" class="text-[10px] text-cyber-violet uppercase mt-2 hidden">Settings saved.</p>
    </div>
  </section>


  <!-- WiFi Map Screen -->
  <section id="wifiMapScreen" class="hidden relative flex min-h-[100dvh] w-full flex-col bg-black text-slate-100 overflow-hidden holo-layer holo-scanlines">
    <!-- Map header -->
    <div class="w-full flex items-center justify-between p-4 sm:p-6 border-b border-ethereal-blue/10 bg-void-black/80 backdrop-blur-md">
      <div class="flex items-center gap-2">
        <span class="material-symbols-outlined text-ethereal-blue text-xl sm:text-2xl">public</span>
        <h2 class="text-ethereal-blue text-sm sm:text-lg font-bold leading-tight tracking-tight italic glitch-text">*</h2>
        <h2 class="text-ethereal-blue text-sm sm:text-lg font-bold leading-tight tracking-tight italic glitch-text">LOCAL_NET_CONSTELLATION</h2>
      </div>
      <div class="flex items-center gap-4">
        <div class="flex flex-col items-end">
          <span class="text-[9px] text-ethereal-blue/50 uppercase">Sys_Load</span>
          <div class="h-1 w-16 bg-engine-iron rounded-full overflow-hidden">
            <div class="h-full bg-ethereal-blue w-2/3"></div>
          </div>
        </div>
        <button class="tap-glow size-9 rounded-full bg-ethereal-blue/10 border border-ethereal-blue/30 flex items-center justify-center text-ethereal-blue" type="button">
          <span class="material-symbols-outlined">computer</span>
        </button>
      </div>
    </div>
    <!-- Map inner area -->
    <div class="relative flex-1 flex flex-col overflow-hidden">
      <!-- Wireframe and rain effects -->
      <div class="absolute inset-0 wireframe-bg opacity-40 pointer-events-none"></div>
      <div class="absolute inset-0 digital-rain-overlay pointer-events-none"></div>
      <!-- Title and protocol -->
      <div class="p-4 pt-6 z-10">
        <p class="text-primary italic text-xl sm:text-2xl font-bold leading-tight tracking-tighter uppercase glitch-text">
          *LOCAL_NET_CONSTELLATION*
        </p>
        <p class="text-[9px] text-ethereal-blue/40 font-mono mt-1 tracking-widest uppercase">
          Protocol: Native_Scan_Backend // Active_Nodes: <span id="mapActiveNodes">0</span>
        </p>
      </div>
      <!-- Map interactive area -->
      <div class="flex-1 relative">
        <div class="absolute inset-0 flex items-center justify-center">
          <div class="relative w-full h-full p-4">
            <!-- Map container -->
            <div class="w-full h-full rounded-lg border border-ethereal-blue/10 bg-black/40 relative overflow-hidden flex items-center justify-center">
              <!-- Top-left control icons -->
              <div class="absolute top-4 left-4 z-20 flex flex-col gap-2 bg-engine-iron/90 border border-ethereal-blue/30 p-2 rounded">
                <span class="material-symbols-outlined text-ethereal-blue text-sm">filter_center_focus</span>
                <span class="material-symbols-outlined text-ethereal-blue text-sm">layers</span>
              </div>
              <!-- Central radar -->
              <div class="relative w-full h-full flex items-center justify-center">
                <div id="holoMapViewport" class="absolute inset-0 holo-map-viewport">
                  <canvas id="holoMapCanvas" class="absolute inset-0 w-full h-full"></canvas>
                  <div id="holoMapTooltip" class="holo-map-node-tooltip"></div>
                </div>
                <!-- Central numeric indicator -->
                <div class="relative w-28 h-28 sm:w-32 sm:h-32 rounded-full border-2 border-ethereal-blue shadow-[0_0_30px_rgba(0,212,255,0.5)] overflow-hidden bg-black/80 flex items-center justify-center">
                  <div class="absolute inset-0 bg-gradient-to-tr from-cyber-violet/30 via-transparent to-ethereal-blue/20"></div>
                  <div id="mapValue" class="text-ethereal-blue text-5xl sm:text-6xl font-black italic opacity-80 glitch-text">0</div>
                  <div class="absolute inset-0 border-[6px] sm:border-[8px] border-ethereal-blue/20 border-dotted rounded-full"></div>
                </div>
              </div>
              <!-- Search & sliders -->
              <div class="absolute bottom-4 left-4 right-4 flex flex-col gap-4">
                <div class="flex items-center gap-3 bg-engine-iron/80 border border-ethereal-blue/30 p-3 rounded">
                  <span class="material-symbols-outlined text-ethereal-blue text-sm">search</span>
                  <input id="mapSearchInput" class="bg-transparent border-none text-ethereal-blue placeholder:text-ethereal-blue/40 text-xs focus:ring-0 w-full uppercase" placeholder="SEARCH SSID OR BSSID..." />
                </div>
                <div class="flex justify-between items-center px-2">
                  <div class="flex flex-col gap-1 w-24">
                    <div class="h-1 bg-ethereal-blue/20 rounded-full relative">
                      <div class="absolute left-1/3 size-3 -top-1 bg-ethereal-blue rounded-full shadow-[0_0_8px_#00d4ff]"></div>
                    </div>
                    <span class="text-[8px] text-ethereal-blue/60 uppercase">Zoom_Lvl</span>
                  </div>
                  <div class="flex flex-col gap-1 w-24">
                    <div class="h-1 bg-ethereal-blue/20 rounded-full relative">
                      <div class="absolute left-2/3 size-3 -top-1 bg-ethereal-blue rounded-full shadow-[0_0_8px_#00d4ff]"></div>
                    </div>
                    <span class="text-[8px] text-ethereal-blue/60 uppercase">Scan_Freq</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- Node summary cards -->
      <div id="mapNodesList" class="px-4 py-6 grid grid-cols-2 gap-4"></div>
      <!-- Overdrive and Cloak buttons (adapted from wifi_map.html) -->
      <div class="absolute bottom-32 left-4 flex flex-col gap-3 z-30">
        <!-- Overdrive button -->
        <button id="mapOverdriveBtn" class="shard-clip-alt bg-cyber-violet/20 border border-ethereal-blue/30 text-ethereal-blue font-black px-4 py-2 uppercase italic flex items-center gap-1 tap-glow" type="button">
          <span class="material-symbols-outlined text-sm">bolt</span>
          Overdrive
        </button>
        <!-- Cloak button -->
        <button id="mapCloakBtn" class="shard-clip bg-engine-iron/80 border border-cyber-violet/40 text-ethereal-blue font-black px-4 py-2 uppercase italic flex items-center gap-1 tap-glow" type="button">
          <span class="material-symbols-outlined text-sm">shield_with_heart</span>
          Cloak
        </button>
      </div>
      <!-- Anomaly detection card -->
      <div id="mapAlertCard" class="absolute bottom-32 right-4 bg-engine-iron/80 border border-danger/50 p-3 w-44 z-30">
        <div class="flex items-center gap-2 mb-1">
          <div class="size-2 bg-danger rounded-full shadow-[0_0_8px_#ff3c00]"></div>
          <div id="mapScanStatus" class="text-[10px] text-danger uppercase font-black">Awaiting Live Scan</div>
        </div>
        <div id="mapAlertText" class="text-slate-400 font-mono text-[9px] leading-tight">
          Trigger Scan To Populate<br/>
          Last Sync: <span id="mapLastSync">Never</span><br/>
          Source: Native Bridge
        </div>
      </div>
    </div>
    <!-- Pulses bottom center -->
    <div class="absolute inset-x-0 bottom-20 h-12 flex justify-center pointer-events-none">
      <div class="w-full max-w-xs h-full flex items-center justify-around">
        <div class="size-1 bg-ethereal-blue/40 rounded-full"></div>
        <div class="size-1.5 bg-ethereal-blue rounded-full shadow-[0_0_5px_#00d4ff]"></div>
        <div class="size-1 bg-ethereal-blue/40 rounded-full"></div>
      </div>
    </div>
  </section>

  <div id="engineScreen" class="relative flex min-h-[100dvh] w-full flex-col justify-between bg-black holo-layer holo-scanlines">

    <!-- Header video (speed.mp4) -->
    <div class="relative z-30 w-full header-video-frame">
      <div class="px-4 sm:px-6 pt-4 sm:pt-6 pb-3 sm:pb-4">
        <div class="w-full rounded-xl overflow-hidden border border-white/10 bg-black/50">
          <video
            id="headerVid"
            class="w-full max-h-[140px] sm:max-h-[180px] object-contain bg-black"
            src="speed.mp4"
            autoplay
            muted
            loop
            playsinline
          ></video>
        </div>
      </div>
    </div>

    <header class="relative z-20 flex items-center justify-between p-4 pt-3 sm:p-6 sm:pt-6 bg-gradient-to-b from-void-black/75 to-transparent">
      <div class="flex flex-col">
        <span class="text-[10px] tracking-[0.3em] text-ethereal-blue/70 font-mono uppercase">SYSTEM STATUS</span>
        <h2 class="text-sm sm:text-base leading-tight flex items-center gap-2 italic-heavy chromatic-aberration" style="color:#dfff11;">
          <span class="material-symbols-outlined text-base">terminal</span>
          PSYCHO-ENGINE / HOLO MERGE
        </h2>
      </div>

      <div class="flex gap-4 items-center">
        <div class="text-right hidden sm:block">
          <p class="text-[10px] text-slate-500 uppercase font-mono">Neural Link</p>
          <p class="text-xs font-bold text-cyber-violet font-mono tracking-widest">ENCRYPTED</p>
        </div>

        <button id="btnSettings" class="tap-glow size-10 rounded-full bg-ethereal-blue/10 border border-ethereal-blue/30 flex items-center justify-center text-ethereal-blue" type="button">
          <span class="material-symbols-outlined">settings_input_component</span>
        </button>
      </div>
    </header>

    <main class="relative z-20 flex-1 min-h-0 flex flex-col items-center justify-center px-4 sm:px-6 perspective-center">
      <div class="absolute inset-0 z-0 opacity-20">
        <div class="absolute inset-0 bg-[radial-gradient(circle_at_center,_transparent_0%,_#020408_70%)] z-10"></div>
        <div class="w-full h-full bg-center bg-cover scale-110"
             style="background-image:
               radial-gradient(circle at 50% 35%, rgba(0, 212, 255, 0.16), transparent 34%),
               radial-gradient(circle at 50% 58%, rgba(157, 80, 187, 0.14), transparent 40%),
               linear-gradient(135deg, #000000 0%, #000000 100%);">
        </div>
      </div>

      <div class="relative z-10 flex flex-col items-center w-full max-w-sm sm:max-w-md">

        <div class="absolute -top-12 left-0 right-0 flex justify-between px-6 opacity-90 rotate-x-25" aria-hidden="true">
          <div class="flex flex-col items-start border-l-2 border-ethereal-blue/40 pl-2">
            <span class="text-[9px] text-ethereal-blue uppercase tracking-widest font-mono">Heat Level</span>
            <span id="heatLabel" class="text-sm font-black text-ethereal-blue">IDLE</span>
          </div>
          <div class="flex flex-col items-end border-r-2 border-cyber-violet/40 pr-2">
            <span class="text-[9px] text-cyber-violet uppercase tracking-widest font-mono">Pressure</span>
            <span id="pressureLabel" class="text-sm font-black text-cyber-violet">STABLE</span>
          </div>
        </div>

        <div class="relative group w-full flex items-center justify-center">
          <div id="aura" class="absolute -inset-10 bg-ethereal-blue/10 blur-3xl rounded-full" style="animation: holoPulse 4.5s ease-in-out infinite;"></div>
          <!-- Spinning diamond frame around the gauge -->
          <div class="absolute -inset-6 sm:-inset-8 rounded-3xl rotate-45 opacity-55 border-2 animate-[spin_60s_linear_infinite]" style="border-color:rgba(255,0,255,0.55);"></div>
          <div class="absolute -inset-10 sm:-inset-12 rounded-3xl rotate-45 opacity-50 border-2 border-dashed animate-[spin_72s_linear_infinite_reverse]" style="border-color:rgba(223,255,17,0.72);"></div>

          <div class="relative size-64 sm:size-80 flex items-center justify-center transform-gpu holo-gauge-shell">
            <canvas id="gaugeParticlesCanvas" class="holo-gauge-canvas opacity-45"></canvas>
            <canvas id="gaugeCompositeCanvas" class="holo-gauge-canvas opacity-95"></canvas>

            <div class="absolute inset-2 rounded-full border border-ethereal-blue/15"></div>
            <div class="absolute inset-0 gauge-conic opacity-35"></div>

            <div class="absolute inset-0 flex items-center justify-center">
              <div id="needlePivot" class="absolute w-full h-full flex items-center justify-center" style="transform: rotate(140deg); will-change: transform;">
                <div class="relative w-44 sm:w-52 flex items-center justify-end origin-left">
                  <div class="w-28 sm:w-32 h-[2px] bg-gradient-to-r from-transparent via-[#7ef5ff] to-white rounded-full shadow-[0_0_18px_rgba(0,212,255,0.78)]"></div>
                  <div class="absolute -right-1 w-2.5 h-2.5 bg-white rounded-full blur-[1px] shadow-[0_0_12px_rgba(255,255,255,0.95)]"></div>
                </div>
                <div class="absolute w-40 h-14 bg-ethereal-blue/10 blur-xl rounded-full -left-16 origin-right"></div>
              </div>
              <div class="absolute w-5 h-5 rounded-full bg-[#9bf7ff] shadow-[0_0_18px_rgba(0,212,255,0.8),0_0_30px_rgba(255,255,255,0.5)]"></div>
            </div>

            <div class="relative z-20 size-48 sm:size-56 bg-panel/70 soft-frost rounded-2xl border-2 border-ethereal-blue/35 glitch-border p-4 flex flex-col items-center justify-center overflow-hidden">
              <div class="absolute inset-0 opacity-15 scanline-mask"></div>
              <div class="holo-scan-sweep opacity-30"></div>
              <div class="absolute inset-0 bg-[linear-gradient(160deg,rgba(255,255,255,0.26)_0%,rgba(255,255,255,0.03)_33%,transparent_48%)] mix-blend-screen opacity-35 pointer-events-none"></div>

              <div class="relative z-10 flex flex-col items-center select-none">
                <span id="phaseLabel" class="text-[10px] tracking-[0.5em] text-[#b7ff00]/90 font-mono font-bold mb-1 uppercase italic neon-yellow-readout">IDLE</span>

                <div class="flex items-baseline gap-1 chromatic-aberration">
                  <span id="mainInt" class="text-6xl sm:text-7xl font-black italic text-[#b7ff00] tracking-tighter leading-none neon-yellow-readout digital-shimmer" style="font-family:'Orbitron', sans-serif; letter-spacing:-0.03em;">0</span>
                  <span id="mainFrac" class="text-xl font-black italic text-[#b7ff00] neon-yellow-readout digital-shimmer" style="font-family:'Orbitron', sans-serif;">.0</span>
                </div>

                <span id="unitLabel" class="text-lg font-bold text-[#b7ff00] tracking-widest mt-2 neon-yellow-readout">Mbps</span>

                <div class="mt-2 grid grid-cols-2 gap-x-3 gap-y-1 text-[9px] font-mono uppercase tracking-wider text-white/75 digital-shimmer">
                  <span class="micro-metric">Up <span id="microUpVal" class="text-cyber-violet">0.0</span></span>
                  <span class="micro-metric">Ping <span id="microPingVal" class="text-ethereal-blue">--</span></span>
                  <span class="micro-metric">Jit <span id="microJitterVal" class="text-ethereal-blue">--</span></span>
                  <span class="micro-metric">Loss <span id="microLossVal" class="text-danger">--</span></span>
                </div>

                <div class="mt-3 flex items-center gap-2 font-mono text-[10px] text-white/60">
                  <span class="inline-flex items-center gap-1">
                    <span class="w-1.5 h-1.5 rounded-full bg-ethereal-blue shadow-[0_0_8px_#00d4ff]"></span>
                    <span id="statusText">READY</span>
                  </span>
                  <span class="opacity-50">|</span>
                  <span id="timerText" class="tracking-widest">00:00</span>
                </div>
              </div>

              <div class="absolute bottom-0 left-0 right-0 h-16 opacity-25 data-heart-glow">
                <svg class="w-full h-full text-ethereal-blue" viewBox="0 0 200 100" preserveAspectRatio="none">
                  <path id="wavePath" d="M0 100 L20 40 L40 80 L60 20 L80 90 L100 10 L120 70 L140 30 L160 85 L180 45 L200 100 Z" fill="currentColor"></path>
                </svg>
              </div>

              <div id="scanJitter" class="absolute inset-0 pointer-events-none opacity-0"></div>
            </div>

            <div class="absolute -top-4 -right-4 size-12 bg-cyber-violet/20 border border-cyber-violet/50 nitro-shard flex items-center justify-center">
              <span class="material-symbols-outlined text-cyber-violet text-sm">bolt</span>
            </div>
          </div>
        </div>

        <div class="mt-10 sm:mt-12 grid grid-cols-3 gap-3 w-full px-2">
          <div class="bg-engine-iron/55 border-l border-ethereal-blue/40 p-3 rounded-sm">
            <p class="text-[8px] text-slate-500 uppercase font-bold tracking-widest font-mono">Latency</p>
            <p class="text-lg font-black text-slate-100">
              <span id="latencyVal">--</span><span class="text-[10px] text-ethereal-blue ml-1 font-mono">MS</span>
            </p>
          </div>
          <div class="bg-engine-iron/55 border-l border-ethereal-blue/40 p-3 rounded-sm">
            <p class="text-[8px] text-slate-500 uppercase font-bold tracking-widest font-mono">Jitter</p>
            <p class="text-lg font-black text-slate-100">
              <span id="jitterVal">--</span><span class="text-[10px] text-ethereal-blue ml-1 font-mono">MS</span>
            </p>
          </div>
          <div class="bg-engine-iron/55 border-l border-ethereal-blue/40 p-3 rounded-sm">
            <p class="text-[8px] text-slate-500 uppercase font-bold tracking-widest font-mono">Loss</p>
            <p class="text-lg font-black text-slate-100">
              <span id="lossVal">--</span><span class="text-[10px] text-ethereal-blue ml-1 font-mono">%</span>
            </p>
          </div>
        </div>

        <div class="mt-4 grid grid-cols-2 gap-3 w-full px-2">
          <div class="bg-panel/35 border border-white/5 p-3 rounded-md">
            <p class="text-[9px] text-slate-500 uppercase font-mono tracking-widest">Downlink</p>
            <p class="text-sm font-mono text-white"><span id="downVal">0.0</span> <span class="text-ethereal-blue">Mbps</span></p>
          </div>
          <div class="bg-panel/35 border border-white/5 p-3 rounded-md">
            <p class="text-[9px] text-slate-500 uppercase font-mono tracking-widest">Uplink</p>
            <p class="text-sm font-mono text-white"><span id="upVal">0.0</span> <span class="text-cyber-violet">Mbps</span></p>
          </div>
        </div>

      </div>
    </main>

    <footer class="relative z-30 shrink-0 p-6 pb-10 sm:px-8 sm:pb-12 flex flex-col gap-6">
      
<div class="grid grid-cols-3 gap-3">
        <button id="btnStart" class="cybr-btn cybr-green tap-glow" type="button" aria-label="Engage">
          <span class="cybr-btn__glitch" aria-hidden="true">ENGAGE</span>
          ENGAGE
        </button>

        <button id="btnAbort" class="cybr-btn cybr-pink tap-glow" type="button" aria-label="Abort">
          <span class="cybr-btn__glitch" aria-hidden="true">ABORT</span>
          ABORT
        </button>

        <button id="btnReset" class="cybr-btn cybr-violet tap-glow" type="button" aria-label="Reset">
          <span class="cybr-btn__glitch" aria-hidden="true">RESET</span>
          RESET
        </button>
      </div>

      <!-- bottom nav moved outside engine screen -->

      <div class="absolute bottom-24 left-0 w-full flex justify-center opacity-[0.08] pointer-events-none select-none">
        <span class="text-[96px] sm:text-[120px] font-black tracking-tighter leading-none">OVERDRIVE</span>
      </div>
    </footer>

    <!-- Vertical accent bars for engine screen -->
    <div id="barsLeft" class="absolute top-1/2 left-4 -translate-y-1/2 flex flex-col gap-1 z-0">
      <div class="h-12 w-0.5 bg-ethereal-blue/30"></div>
      <div class="h-2 w-0.5 bg-cyber-violet"></div>
      <div class="h-20 w-0.5 bg-ethereal-blue/10"></div>
    </div>
    <div id="barsRight" class="absolute top-1/2 right-4 -translate-y-1/2 flex flex-col gap-1 z-0 items-end">
      <div class="h-20 w-0.5 bg-ethereal-blue/10"></div>
      <div class="h-2 w-0.5 bg-ethereal-blue"></div>
      <div class="h-12 w-0.5 bg-cyber-violet/30"></div>
    </div>

  </div>


  <!-- Global bottom navigation -->
  <nav id="bottomNav" class="app-nav fixed bottom-0 left-0 right-0 z-40">
    <div class="flex gap-2 px-4 pb-8 pt-4">
      <button id="navEngine" class="nav-tab italic-heavy flex-1" type="button" aria-label="Core engine tab">
        <span class="nav-icon-word" aria-hidden="true">SPEED</span>
        <span class="tab-label"><span class="nav-emoji" aria-hidden="true">⚙️</span> Core</span>
      </button>
      <button id="navList" class="nav-tab italic-heavy flex-1" type="button" aria-label="Device list tab">
        <span class="nav-icon-word" aria-hidden="true">INSIGHTS</span>
        <span class="tab-label"><span class="nav-emoji" aria-hidden="true">📡</span> Graph</span>
      </button>
      <button id="navMap" class="nav-tab italic-heavy flex-1" type="button" aria-label="Network map tab">
        <span class="nav-icon-word" aria-hidden="true">PUBLIC</span>
        <span class="tab-label"><span class="nav-emoji" aria-hidden="true">🛰️</span> Nodes</span>
      </button>
      <button id="navConfig" class="nav-tab italic-heavy flex-1" type="button" aria-label="Security settings tab">
        <span class="nav-icon-word" aria-hidden="true">SAFETY</span>
        <span class="tab-label"><span class="nav-emoji" aria-hidden="true">🛡️</span> Shield</span>
      </button>
    </div>
  </nav>

  <script src="holo-motion.js"></script>
  <script>
    (() => {
      const $ = (id) => document.getElementById(id);

      const ui = {
        btnStart: $("btnStart"),
        btnAbort: $("btnAbort"),
        btnReset: $("btnReset"),

        heatLabel: $("heatLabel"),
        pressureLabel: $("pressureLabel"),
        phaseLabel: $("phaseLabel"),
        unitLabel: $("unitLabel"),
        statusText: $("statusText"),
        timerText: $("timerText"),

        mainInt: $("mainInt"),
        mainFrac: $("mainFrac"),

        latencyVal: $("latencyVal"),
        jitterVal: $("jitterVal"),
        lossVal: $("lossVal"),

        downVal: $("downVal"),
        upVal: $("upVal"),
        microUpVal: $("microUpVal"),
        microPingVal: $("microPingVal"),
        microJitterVal: $("microJitterVal"),
        microLossVal: $("microLossVal"),

        needlePivot: $("needlePivot"),
        gaugeParticlesCanvas: $("gaugeParticlesCanvas"),
        gaugeCompositeCanvas: $("gaugeCompositeCanvas"),
        aura: $("aura"),
        scanJitter: $("scanJitter"),
        wavePath: $("wavePath"),
      };

      const nativeUi = {
        wifiDeviceList: $("wifiDeviceList"),
        wifiEmptyState: $("wifiEmptyState"),
        wifiScanMeta: $("wifiScanMeta"),
        wifiBridgeState: $("wifiBridgeState"),
        wifiPermissionState: $("wifiPermissionState"),
        wifiScanState: $("wifiScanState"),
        wifiStateBadge: $("wifiStateBadge"),
        wifiStateMessage: $("wifiStateMessage"),
        wifiIntelCount: $("wifiIntelCount"),
        wifiIntelSignal: $("wifiIntelSignal"),
        wifiIntelBand: $("wifiIntelBand"),
        wifiIntelStatus: $("wifiIntelStatus"),
        wifiScanBtn: $("wifiScanBtn"),
        wifiExportBtn: $("wifiExportBtn"),
        holoMapViewport: $("holoMapViewport"),
        holoMapCanvas: $("holoMapCanvas"),
        holoMapTooltip: $("holoMapTooltip"),
        mapNodesList: $("mapNodesList"),
        mapSearchInput: $("mapSearchInput"),
        mapActiveNodes: $("mapActiveNodes"),
        mapValue: $("mapValue"),
        mapScanStatus: $("mapScanStatus"),
        mapAlertText: $("mapAlertText"),
        mapLastSync: $("mapLastSync"),
        mapOverdriveBtn: $("mapOverdriveBtn"),
        mapCloakBtn: $("mapCloakBtn"),
        cfgBridgeSummary: $("cfgBridgeSummary"),
        cfgDeviceSummary: $("cfgDeviceSummary"),
        cfgRefreshDeviceBtn: $("cfgRefreshDeviceBtn"),
        cfgExportDiagBtn: $("cfgExportDiagBtn"),
      };

      const State = Object.freeze({
        IDLE: "IDLE",
        PING: "PING",
        DOWNLOAD: "DOWNLOAD",
        UPLOAD: "UPLOAD",
        DONE: "DONE",
        ABORTED: "ABORTED",
      });

      let state = State.IDLE;

      let cur = {
        ping: null,
        jitter: null,
        loss: null,
        down: 0,
        up: 0,
        display: 0,
        needleDeg: 140,
        needleTarget: 140,
        needleVel: 0,
        sweepStart: 0,
      };

      let raf = 0;
      let phaseStart = 0;
      let runStart = 0;
      let aborted = false;

      const motion = window.HoloMotion || { clamp: (v,a,b) => Math.max(a, Math.min(b, v)), lerp: (a,b,t)=>a+(b-a)*t, spring: (c,t,s)=>c+((t-c)*s), attachParallax:()=>()=>{}, animate:(f)=>{let id=requestAnimationFrame(function loop(ts){f(ts);id=requestAnimationFrame(loop);}); return ()=>cancelAnimationFrame(id);}, reducedMotion:false };
      const clamp = motion.clamp;
      const ease = (x) => {
        x = clamp(x, 0, 1);
        return x * x * (3 - 2 * x);
      };
      const lerp = motion.lerp;

      class HoloGaugeRenderer {
        constructor(particlesCanvas, compositeCanvas) {
          this.particlesCanvas = particlesCanvas;
          this.compositeCanvas = compositeCanvas;
          this.pCtx = particlesCanvas?.getContext("2d", { alpha: true });
          this.cCtx = compositeCanvas?.getContext("2d", { alpha: true });
          this.particles = Array.from({ length: 42 }, () => ({
            x: Math.random(),
            y: Math.random(),
            s: 0.4 + Math.random() * 1.6,
            v: 0.0002 + Math.random() * 0.0007,
          }));
          this.radius = 0;
          this.cx = 0;
          this.cy = 0;
          this.pixelRatio = 1;
          this.resize = this.resize.bind(this);
          this.resize();
          window.addEventListener("resize", this.resize, { passive: true });
        }

        resize() {
          const fit = (canvas) => {
            if (!canvas) return;
            const rect = canvas.getBoundingClientRect();
            const ratio = Math.min(window.devicePixelRatio || 1, 2);
            canvas.width = Math.max(1, Math.floor(rect.width * ratio));
            canvas.height = Math.max(1, Math.floor(rect.height * ratio));
            const ctx = canvas.getContext("2d", { alpha: true });
            if (ctx) ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
            this.pixelRatio = ratio;
            this.cx = rect.width * 0.5;
            this.cy = rect.height * 0.5;
            this.radius = Math.min(rect.width, rect.height) * 0.47;
          };
          fit(this.particlesCanvas);
          fit(this.compositeCanvas);
        }

        render(now, needleDeg, valueMbps) {
          if (!this.pCtx || !this.cCtx) return;
          const p = this.pCtx;
          const c = this.cCtx;
          const w = this.particlesCanvas.getBoundingClientRect().width;
          const h = this.particlesCanvas.getBoundingClientRect().height;
          const t = now * 0.001;
          const intensity = clamp(valueMbps / 1000, 0, 1);

          p.clearRect(0, 0, w, h);
          p.fillStyle = "#000";
          p.fillRect(0, 0, w, h);
          for (const dot of this.particles) {
            dot.y += dot.v;
            if (dot.y > 1.05) {
              dot.y = -0.05;
              dot.x = Math.random();
            }
            const x = dot.x * w;
            const y = dot.y * h;
            p.fillStyle = `rgba(0, 220, 255, ${0.08 + dot.s * 0.06})`;
            p.beginPath();
            p.arc(x, y, dot.s, 0, Math.PI * 2);
            p.fill();
          }

          c.clearRect(0, 0, w, h);
          c.save();
          c.translate(this.cx, this.cy);

          c.strokeStyle = "rgba(0,220,255,0.35)";
          c.lineWidth = 1.4;
          c.beginPath();
          c.arc(0, 0, this.radius, 0, Math.PI * 2);
          c.stroke();

          for (let i = 0; i <= 80; i++) {
            const a = (-225 + i * 3.4) * (Math.PI / 180);
            const isMajor = i % 5 === 0;
            const r1 = this.radius - (isMajor ? 16 : 10);
            const highWarn = i >= 66;
            c.strokeStyle = highWarn ? `rgba(255,80,20,${0.2 + intensity * 0.65})` : "rgba(120,250,255,0.28)";
            c.lineWidth = isMajor ? 2.1 : 1;
            c.beginPath();
            c.moveTo(Math.cos(a) * r1, Math.sin(a) * r1);
            c.lineTo(Math.cos(a) * this.radius, Math.sin(a) * this.radius);
            c.stroke();
          }

          c.globalCompositeOperation = "lighter";
          c.strokeStyle = "rgba(0,220,255,0.25)";
          c.lineWidth = 2;
          c.beginPath();
          c.arc(0, 0, this.radius * 0.72, t * 0.8, t * 0.8 + Math.PI * 1.35);
          c.stroke();
          c.strokeStyle = "rgba(160,90,255,0.3)";
          c.beginPath();
          c.arc(0, 0, this.radius * 0.58, -t * 1.2, -t * 1.2 + Math.PI * 1.18);
          c.stroke();

          c.rotate((needleDeg - 90) * (Math.PI / 180));
          const beamGrad = c.createLinearGradient(0, 0, this.radius * 0.86, 0);
          beamGrad.addColorStop(0, "rgba(255,255,255,0)");
          beamGrad.addColorStop(0.45, "rgba(120,250,255,0.5)");
          beamGrad.addColorStop(1, "rgba(255,255,255,0.95)");
          c.strokeStyle = beamGrad;
          c.lineWidth = 2.6;
          c.beginPath();
          c.moveTo(0, 0);
          c.lineTo(this.radius * 0.85, 0);
          c.stroke();

          c.restore();
        }
      }

      const gaugeRenderer = new HoloGaugeRenderer(ui.gaugeParticlesCanvas, ui.gaugeCompositeCanvas);

      const fmt1 = (v) => (Math.round(v * 10) / 10).toFixed(1);
      const fmtIntFrac = (v) => {
        const fixed = fmt1(v);
        const [i, f] = fixed.split(".");
        return { i, f };
      };

      const setMainReadout = (v) => {
        const { i, f } = fmtIntFrac(v);
        ui.mainInt.textContent = i;
        ui.mainFrac.textContent = "." + f;
      };

      const setThroughputReadout = (mbps) => {
        if (mbps >= 1000) {
          ui.unitLabel.textContent = "Gbps";
          setMainReadout(mbps / 1000);
          return;
        }
        ui.unitLabel.textContent = "Mbps";
        setMainReadout(mbps);
      };

      const setNeedleAngle = (deg) => {
        cur.needleDeg = clamp(deg, 50, 320);
        ui.needlePivot.style.transform = `rotate(${cur.needleDeg.toFixed(2)}deg)`;
      };

      const setNeedleTarget = (deg) => {
        cur.needleTarget = clamp(deg, 50, 320);
      };

      const advanceNeedle = (dtMs) => {
        const dt = Math.min(0.05, dtMs / 1000);
        const stiffness = 32;
        const damping = 11;
        const accel = (cur.needleTarget - cur.needleDeg) * stiffness - cur.needleVel * damping;
        cur.needleVel += accel * dt;
        setNeedleAngle(cur.needleDeg + cur.needleVel * dt * 95);
      };

      const updateGaugeColorProfile = (speedValue) => {
        const value = Number(speedValue || 0);
        const intensity = clamp(value / 1000, 0, 1);
        const danger = clamp((value - 780) / 220, 0, 1);
        const yellowGlow = 0.35 + intensity * 0.45;
        const magentaGlow = 0.12 + intensity * 0.25;
        ui.aura.style.background = `radial-gradient(circle, rgba(250,255,0,${yellowGlow.toFixed(3)}) 0%, rgba(0,212,255,${(0.18 + intensity * 0.25).toFixed(3)}) 36%, rgba(255,0,255,${magentaGlow.toFixed(3)}) 58%, rgba(255,80,25,${(danger * 0.45).toFixed(3)}) 72%, rgba(0,0,0,0) 84%)`;
        ui.wavePath.style.color = value > 780 ? '#ff4a1a' : value > 350 ? '#ff00ff' : value > 120 ? '#00d4ff' : '#b7ff00';
        ui.scanJitter.style.background = `radial-gradient(circle at 50% 50%, rgba(250,255,0,${(0.10 + intensity * 0.24).toFixed(3)}) 0%, rgba(255,0,255,${(0.06 + intensity * 0.18).toFixed(3)}) 45%, rgba(0,0,0,0) 80%)`;
        ui.gaugeCompositeCanvas.style.opacity = (0.75 + intensity * 0.25 + danger * 0.1).toFixed(2);
      };

      const setPhase = (s) => {
        state = s;
        ui.phaseLabel.textContent = s;

        ui.statusText.textContent =
          s === State.IDLE ? "READY" :
          s === State.PING ? "PROBING" :
          s === State.DOWNLOAD ? "DOWNLINK" :
          s === State.UPLOAD ? "UPLINK" :
          s === State.DONE ? "COMPLETE" :
          s === State.ABORTED ? "ABORTED" : "ACTIVE";

        ui.heatLabel.textContent =
          s === State.IDLE ? "IDLE" :
          s === State.PING ? "WARMING" :
          s === State.DOWNLOAD ? "CRITICAL" :
          s === State.UPLOAD ? "CRITICAL" :
          s === State.DONE ? "COOLING" :
          s === State.ABORTED ? "CUT" : "ACTIVE";

        ui.pressureLabel.textContent =
          s === State.IDLE ? "STABLE" :
          s === State.PING ? "RISING" :
          s === State.DOWNLOAD ? "OVERLOAD" :
          s === State.UPLOAD ? "OVERLOAD" :
          s === State.DONE ? "VENTING" :
          s === State.ABORTED ? "DUMPED" : "ACTIVE";

        const scanning = (s === State.PING || s === State.DOWNLOAD || s === State.UPLOAD);
        ui.scanJitter.style.opacity = scanning ? "1" : "0";
        ui.scanJitter.style.animation = scanning ? "jitter 0.5s infinite" : "none";

        ui.aura.style.opacity = scanning ? "0.72" : "0.42";
        ui.aura.style.filter = scanning ? "blur(40px) saturate(1.25)" : "blur(30px)";
        ui.needlePivot.parentElement.style.mixBlendMode = scanning ? "screen" : "normal";
        ui.phaseLabel.style.color = "#b7ff00";
        ui.unitLabel.style.color = "#b7ff00";
        ui.mainInt.style.color = scanning ? "#b7ff00" : "#b7ff00";
        ui.mainFrac.style.color = scanning ? "#b7ff00" : "#b7ff00";
      };

      const lockButtons = (locked) => {
        ui.btnStart.disabled = locked;
        ui.btnAbort.disabled = !locked;
        ui.btnReset.disabled = locked;
      };

      const mmss = (ms) => {
        const s = Math.floor(ms / 1000);
        const m = Math.floor(s / 60);
        const r = s % 60;
        return String(m).padStart(2, "0") + ":" + String(r).padStart(2, "0");
      };

      const resetUI = () => {
        aborted = false;
        setPhase(State.IDLE);
        lockButtons(false);

        cur.ping = null;
        cur.jitter = null;
        cur.loss = null;
        cur.down = 0;
        cur.up = 0;
        cur.display = 0;
        cur.needleDeg = 140;

        ui.latencyVal.textContent = "--";
        ui.jitterVal.textContent = "--";
        ui.lossVal.textContent = "--";
        ui.downVal.textContent = "0.0";
        ui.upVal.textContent = "0.0";
        ui.microUpVal.textContent = "0.0";
        ui.microPingVal.textContent = "--";
        ui.microJitterVal.textContent = "--";
        ui.microLossVal.textContent = "--";

        ui.unitLabel.textContent = "Mbps";
        ui.timerText.textContent = "00:00";

        setMainReadout(0);
        setNeedleAngle(cur.needleDeg);
        setNeedleTarget(cur.needleDeg);
        updateGaugeColorProfile(cur.display);
        gaugeRenderer.render(performance.now(), cur.needleDeg, cur.display);

        ui.wavePath.setAttribute("d", "M0 100 L20 40 L40 80 L60 20 L80 90 L100 10 L120 70 L140 30 L160 85 L180 45 L200 100 Z");
      };

      const rand = (a, b) => a + Math.random() * (b - a);

      const profile = {
        pingMs: () => Math.round(rand(8, 22)),
        jitterMs: () => Math.round(rand(1, 6)),
        lossPct: () => Math.round(rand(0, 2) * 10) / 10,
        downPeak: () => rand(650, 980),
        upPeak: () => rand(70, 180),
      };

      const needleForMbps = (mbps) => {
        const max = 1000;
        const t = clamp(mbps / max, 0, 1);
        return lerp(50, 320, ease(t));
      };

      const updateWaveform = (timeMs, intensity01) => {
        const wob = (i) => Math.sin((timeMs / 140) + i) * (12 + 22 * intensity01);
        const base = [
          [0,100],[20,40],[40,80],[60,20],[80,90],[100,10],[120,70],[140,30],[160,85],[180,45],[200,100]
        ];
        const pts = base.map(([x,y], idx) => {
          const dy = wob(idx * 0.9) * (idx % 2 === 0 ? 0.35 : 0.55);
          const ny = clamp(y + dy, 4, 98);
          return [x, ny];
        });
        const d = "M" + pts.map(([x,y]) => `${x} ${y.toFixed(1)}`).join(" L ") + " Z";
        ui.wavePath.setAttribute("d", d);
      };

      const PING_DUR = 1200;
      const DOWN_DUR = 5200;
      const UP_DUR = 3800;

      let downPeak = 0;
      let upPeak = 0;

      const startRun = () => {
        if (state !== State.IDLE && state !== State.DONE && state !== State.ABORTED) return;

        aborted = false;
        lockButtons(true);

        runStart = performance.now();
        phaseStart = runStart;
        setPhase(State.PING);

        cur.ping = profile.pingMs();
        cur.jitter = profile.jitterMs();
        cur.loss = profile.lossPct();

        ui.latencyVal.textContent = String(cur.ping);
        ui.jitterVal.textContent = String(cur.jitter);
        ui.lossVal.textContent = String(cur.loss);
        ui.microPingVal.textContent = String(cur.ping);
        ui.microJitterVal.textContent = String(cur.jitter);
        ui.microLossVal.textContent = String(cur.loss);

        cur.display = 0;
        cur.sweepStart = runStart;
        cur.needleVel = 0;
        lastTick = 0;
        setMainReadout(cur.display);
        setNeedleAngle(needleForMbps(0));
        setNeedleTarget(needleForMbps(0));

        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(tick);
      };

      const abortRun = () => {
        if (state === State.IDLE || state === State.DONE || state === State.ABORTED) return;
        aborted = true;
        setPhase(State.ABORTED);
        lockButtons(false);

        ui.unitLabel.textContent = "Mbps";
        ui.statusText.textContent = "ABORTED";
        setNeedleTarget(needleForMbps(0));
        gaugeRenderer.render(performance.now(), cur.needleDeg, cur.display);

        cancelAnimationFrame(raf);
      };

      const finishRun = () => {
        setPhase(State.DONE);
        lockButtons(false);
      };

      let lastTick = 0;
      const tick = (now) => {
        if (aborted) return;

        const elapsed = now - runStart;
        ui.timerText.textContent = mmss(elapsed);
        const dt = lastTick ? (now - lastTick) : 16.7;
        lastTick = now;

        const scanIntensity =
          (state === State.PING) ? 0.35 :
          (state === State.DOWNLOAD) ? 0.85 :
          (state === State.UPLOAD) ? 0.75 :
          0.25;

        updateWaveform(now, scanIntensity);

        if (state === State.PING) {
          const t = ease((now - phaseStart) / PING_DUR);
          ui.unitLabel.textContent = "ms";
          const shown = lerp(0, cur.ping ?? 12, t);
          cur.display = shown;
          setMainReadout(cur.display);

          const sweepRaw = clamp((now - cur.sweepStart) / 850, 0, 1);
          const sweep = sweepRaw < 1 ? (Math.sin(sweepRaw * Math.PI) * 0.9 + sweepRaw) : 1;
          setNeedleTarget(lerp(needleForMbps(0), needleForMbps(120), clamp(sweep, 0, 1)));

          if ((now - phaseStart) >= PING_DUR) {
            phaseStart = now;
            downPeak = profile.downPeak();
            ui.unitLabel.textContent = "Mbps";
            setPhase(State.DOWNLOAD);
          }
        }
        else if (state === State.DOWNLOAD) {
          const raw = (now - phaseStart) / DOWN_DUR;
          const t = ease(raw);

          const ramp = lerp(0, downPeak, t);
          const noise = Math.sin(now / 180) * (downPeak * 0.015) + Math.sin(now / 70) * (downPeak * 0.006);
          const val = clamp(ramp + noise, 0, downPeak * 1.02);

          cur.down = val;
          ui.downVal.textContent = fmt1(cur.down);

          cur.display = val;
          setThroughputReadout(cur.display);
          setNeedleTarget(needleForMbps(val));

          if (raw >= 1) {
            phaseStart = now;
            upPeak = profile.upPeak();
            setPhase(State.UPLOAD);
          }
        }
        else if (state === State.UPLOAD) {
          const raw = (now - phaseStart) / UP_DUR;
          const t = ease(raw);

          const ramp = lerp(0, upPeak, t);
          const noise = Math.sin(now / 200) * (upPeak * 0.03) + Math.sin(now / 90) * (upPeak * 0.01);
          const val = clamp(ramp + noise, 0, upPeak * 1.05);

          cur.up = val;
          ui.upVal.textContent = fmt1(cur.up);
          ui.microUpVal.textContent = fmt1(cur.up);

          cur.display = val;
          setThroughputReadout(cur.display);
          setNeedleTarget(needleForMbps(val));

          if (raw >= 1) {
            setThroughputReadout(cur.down);
            setNeedleTarget(needleForMbps(cur.down));
            advanceNeedle(dt);
            gaugeRenderer.render(now, cur.needleDeg, cur.display);
            finishRun();
            cancelAnimationFrame(raf);
            return;
          }
        }
        else {
          cancelAnimationFrame(raf);
          return;
        }

        advanceNeedle(dt);
        gaugeRenderer.render(now, cur.needleDeg, cur.display);
        updateGaugeColorProfile(state === State.PING ? cur.display * 25 : cur.display);
        raf = requestAnimationFrame(tick);
      };

      ui.btnStart.addEventListener("click", startRun);
      ui.btnAbort.addEventListener("click", abortRun);
      ui.btnReset.addEventListener("click", () => {
        cancelAnimationFrame(raf);
        resetUI();
      });

      $("btnSettings").addEventListener("click", () => {
        const overlay = document.querySelector(".vhs-overlay");
        const curOp = parseFloat(getComputedStyle(overlay).opacity || "0.30");
        overlay.style.opacity = (curOp < 0.35) ? "0.45" : "0.28";
      });

      // Bottom navigation binding and screen toggling
      const nav = {
        engine: document.getElementById("navEngine"),
        list: document.getElementById("navList"),
        map: document.getElementById("navMap"),
        config: document.getElementById("navConfig"),
      };
      const screens = {
        engine: document.getElementById("engineScreen"),
        list: document.getElementById("wifiListScreen"),
        map: document.getElementById("wifiMapScreen"),
        config: document.getElementById("configScreen"),
      };
      const detachParallax = [
        motion.attachParallax(document.getElementById("engineScreen")),
        motion.attachParallax(document.getElementById("wifiMapScreen")),
        motion.attachParallax(document.getElementById("wifiListScreen")),
      ];
      // Grab the decorative vertical bars so they can be hidden when switching screens
      const bars = {
        left: document.getElementById("barsLeft"),
        right: document.getElementById("barsRight"),
      };
      function setActive(tab) {
        // Hide all screens
        Object.values(screens).forEach((s) => {
          if (s) s.classList.add("hidden");
        });
        // Show selected screen if exists
        if (screens[tab]) {
          screens[tab].classList.remove("hidden");
        }
        // Show or hide decorative bars based on active screen
        if (bars.left) bars.left.classList.toggle("hidden", tab !== "engine");
        if (bars.right) bars.right.classList.toggle("hidden", tab !== "engine");
        // Update nav colors
        Object.keys(nav).forEach((k) => {
          nav[k]?.classList.remove("is-active");
        });
        if (nav[tab]) {
          nav[tab].classList.add("is-active");
        }
        if (tab === "map") renderMapFromScan();
      }
      // initial state: engine screen
      setActive("engine");
      // Event bindings
      nav.engine?.addEventListener("click", () => {
        setActive("engine");
        ui.statusText.textContent = "CORE";
      });
      nav.list?.addEventListener("click", () => {
        setActive("list");
        ui.statusText.textContent = "GRAPH";
        ui.scanJitter.style.opacity = "1";
        ui.scanJitter.style.animation = "jitter 0.35s linear 1";
        setTimeout(() => {
          ui.scanJitter.style.opacity = "0";
          ui.statusText.textContent = (state === State.IDLE ? "READY" : ui.statusText.textContent);
        }, 350);
        onListTabSelected();
      });
      nav.map?.addEventListener("click", () => {
        setActive("map");
        ui.statusText.textContent = "NODES";
        ui.scanJitter.style.opacity = "1";
        ui.scanJitter.style.animation = "jitter 0.35s linear 1";
        setTimeout(() => {
          ui.scanJitter.style.opacity = "0";
          ui.statusText.textContent = (state === State.IDLE ? "READY" : ui.statusText.textContent);
        }, 350);
        renderMapFromScan();
      });
      nav.config?.addEventListener("click", () => {
        setActive("config");
        ui.statusText.textContent = "SHIELD";
        ui.scanJitter.style.opacity = "1";
        ui.scanJitter.style.animation = "jitter 0.35s linear 1";
        setTimeout(() => {
          ui.scanJitter.style.opacity = "0";
          ui.statusText.textContent = (state === State.IDLE ? "READY" : ui.statusText.textContent);
        }, 350);
      });

      const NATIVE_EVENT = "netninja:native";
      const cfgKey = "nn_cfg";
      const nativeBridge = {
        available() {
          return !!(window.NetNinjaBridge && typeof window.NetNinjaBridge.getBridgeState === "function");
        },
        call(method, ...args) {
          if (!this.available() || typeof window.NetNinjaBridge[method] !== "function") return null;
          try {
            return JSON.parse(window.NetNinjaBridge[method](...args));
          } catch {
            return null;
          }
        },
      };
      const runtime = {
        bridgeState: {
          available: nativeBridge.available(),
          enabled: false,
          canScan: false,
          scanPermissionGranted: false,
          locationServicesEnabled: false,
        },
        lastDeviceInfo: null,
        lastScanResults: [],
        lastScanSource: "none",
        lastScanCapturedAt: 0,
        mapFilterText: "",
        mapOverdriveEnabled: false,
        mapCloakEnabled: false,
        mapScanInProgress: false,
      };
      const defaultConfig = () => ({
        autoScan: false,
        holoFX: false,
        alerts: false,
        demoMode: false,
        bridgeEnabled: false,
        neonIntensity: 70,
        scanSpeed: 50,
        accentMode: "blue",
        perfMode: "high",
      });
      const cfgCtrls = {
        autoScan: document.getElementById("cfgAutoScan"),
        holoFX: document.getElementById("cfgHoloFX"),
        alerts: document.getElementById("cfgAlerts"),
        demoMode: document.getElementById("cfgDemoMode"),
        bridgeEnabled: document.getElementById("cfgBridgeEnabled"),
        neonIntensity: document.getElementById("cfgNeonIntensity"),
        scanSpeed: document.getElementById("cfgScanSpeed"),
        accentMode: document.getElementById("cfgAccentMode"),
        perfMode: document.getElementById("cfgPerfMode"),
      };
      const cfgSaveBtn = document.getElementById("cfgSaveBtn");
      const cfgResetBtn = document.getElementById("cfgResetBtn");
      const cfgStatusMsg = document.getElementById("cfgStatusMsg");
      let cfgStatusTimer = 0;

      const escapeHtml = (value) => String(value ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll("\"", "&quot;")
        .replaceAll("'", "&#39;");

      const signalAccent = (level) => {
        if (level >= -50) return { color: "#00ff9d", glow: "rgba(0,255,157,0.4)" };
        if (level >= -65) return { color: "#00f3ff", glow: "rgba(0,243,255,0.4)" };
        if (level >= -75) return { color: "#ffaa00", glow: "rgba(255,170,0,0.4)" };
        return { color: "#a855f7", glow: "rgba(168,85,247,0.4)" };
      };

      const formatSecurity = (capabilities) => {
        const label = String(capabilities || "").trim();
        if (!label) return "OPEN";
        if (label.includes("WPA3")) return "WPA3";
        if (label.includes("WPA2")) return "WPA2";
        if (label.includes("WEP")) return "WEP";
        return label.replaceAll("[", "").replaceAll("]", "") || "SECURED";
      };

      function getCurrentConfig() {
        return {
          autoScan: cfgCtrls.autoScan.checked,
          holoFX: cfgCtrls.holoFX.checked,
          alerts: cfgCtrls.alerts.checked,
          demoMode: false,
          bridgeEnabled: cfgCtrls.bridgeEnabled.checked,
          neonIntensity: Number(cfgCtrls.neonIntensity.value),
          scanSpeed: Number(cfgCtrls.scanSpeed.value),
          accentMode: cfgCtrls.accentMode.value,
          perfMode: cfgCtrls.perfMode.value,
        };
      }

      function setConfigControls(data) {
        cfgCtrls.autoScan.checked = !!data.autoScan;
        cfgCtrls.holoFX.checked = !!data.holoFX;
        cfgCtrls.alerts.checked = !!data.alerts;
        cfgCtrls.demoMode.checked = false;
        cfgCtrls.demoMode.disabled = true;
        cfgCtrls.bridgeEnabled.checked = !!data.bridgeEnabled;
        cfgCtrls.neonIntensity.value = Number(data.neonIntensity);
        cfgCtrls.scanSpeed.value = Number(data.scanSpeed);
        cfgCtrls.accentMode.value = data.accentMode;
        cfgCtrls.perfMode.value = data.perfMode;
      }

      function showCfgStatus(message) {
        cfgStatusMsg.textContent = message;
        cfgStatusMsg.classList.remove("hidden");
        clearTimeout(cfgStatusTimer);
        cfgStatusTimer = setTimeout(() => cfgStatusMsg.classList.add("hidden"), 2400);
      }

      function updateBridgeUi() {
        const bridge = runtime.bridgeState;
        nativeUi.wifiBridgeState.textContent = !bridge.available ? "Unavailable" : bridge.enabled ? "Armed" : "Disabled";
        nativeUi.wifiPermissionState.textContent = !bridge.available ? "N/A" : !bridge.locationServicesEnabled ? "Location Services Off" : bridge.scanPermissionGranted ? "Granted" : "Tap Scan To Grant";
        nativeUi.wifiScanState.textContent = !bridge.canScan ? "Hardware Offline" : bridge.enabled ? "Ready" : "Standby";
        nativeUi.cfgBridgeSummary.textContent = !bridge.available
          ? "Native bridge unavailable in this shell."
          : bridge.enabled
            ? (bridge.scanPermissionGranted ? "Bridge enabled. Scan permissions ready." : "Bridge enabled. Scan will request permissions on tap.")
            : "Bridge loaded but disabled by config.";
      }

      function updateDeviceUi() {
        const info = runtime.lastDeviceInfo;
        nativeUi.cfgDeviceSummary.textContent = !info
          ? "No device snapshot yet."
          : `${info.manufacturer} ${info.model} / Android ${info.release} / SDK ${info.sdkInt}`;
      }

      function updateWifiListState(networks, source, meta) {
        const lowerMeta = String(meta || "").toLowerCase();
        let badge = "STANDBY";
        let message = "No networks loaded. Tap Scan for live discovery.";

        if (lowerMeta.includes("request sent") || lowerMeta.includes("scanning") || lowerMeta.includes("await")) {
          badge = "SCANNING";
          message = "Sensor sweep in progress. Awaiting uplink packets.";
        }
        if (lowerMeta.includes("grant") || lowerMeta.includes("permission")) {
          badge = "AUTH";
          message = "Permission gate is blocking active discovery.";
        }
        if (lowerMeta.includes("error") || lowerMeta.includes("failed")) {
          badge = "ERROR";
          message = "Scan feed interrupted. Retry when bridge is stable.";
        }
        if (networks.length > 0) {
          badge = source === "cached" ? "CACHED" : "LIVE";
          message = `${networks.length} targets synchronized in matrix.`;
        }

        if (nativeUi.wifiStateBadge) nativeUi.wifiStateBadge.textContent = badge;
        if (nativeUi.wifiStateMessage) nativeUi.wifiStateMessage.textContent = message;
        if (nativeUi.wifiIntelStatus) {
          nativeUi.wifiIntelStatus.textContent = badge.slice(0, 5);
        }
      }

      function updateWifiCenterIntel(networks) {
        const list = Array.isArray(networks) ? networks : [];
        if (nativeUi.wifiIntelCount) {
          nativeUi.wifiIntelCount.textContent = String(list.length);
        }
        if (list.length === 0) {
          if (nativeUi.wifiIntelSignal) nativeUi.wifiIntelSignal.textContent = "-- dBm";
          if (nativeUi.wifiIntelBand) nativeUi.wifiIntelBand.textContent = "-- MHz";
          return;
        }
        const strongest = list.reduce((best, curr) => Number(curr.signalLevel ?? -120) > Number(best.signalLevel ?? -120) ? curr : best, list[0]);
        if (nativeUi.wifiIntelSignal) {
          nativeUi.wifiIntelSignal.textContent = `${strongest.signalLevel ?? "--"} dBm`;
        }
        if (nativeUi.wifiIntelBand) {
          nativeUi.wifiIntelBand.textContent = strongest.frequency ? `${strongest.frequency} MHz` : "Unknown";
        }
      }

      function renderWifiNetworks(networks, source, meta) {
        runtime.lastScanResults = networks;
        runtime.lastScanSource = source;
        nativeUi.wifiScanMeta.textContent = meta;
        updateWifiListState(networks, source, meta);
        updateWifiCenterIntel(networks);
        nativeUi.wifiEmptyState.classList.toggle("hidden", networks.length > 0);
        nativeUi.wifiDeviceList.innerHTML = networks.map((network, index) => {
          const signalLevel = Number(network.signalLevel ?? -90);
          const accent = signalAccent(signalLevel);
          const signalPct = Math.max(9, Math.min(100, 120 + signalLevel));
          const meterPct = Math.max(8, Math.min(100, 100 - Math.max(0, (Math.abs(signalLevel) - 34))));
          const ssid = escapeHtml(network.ssid || `Hidden-${index + 1}`);
          const bssid = escapeHtml(network.bssid || "N/A");
          const level = escapeHtml(`${network.signalLevel ?? "--"} dBm`);
          const freq = escapeHtml(network.frequency ? `${network.frequency} MHz` : "Unknown band");
          const security = escapeHtml(formatSecurity(network.capabilities));
          const latency = Math.max(8, Math.min(220, Math.round(220 - (meterPct * 1.8))));
          const badge = source === "cached" ? "CACHED" : "LIVE";
          const active = source === "real" && signalLevel > -72;
          return `
            <div class="shard-card p-4 group holo-interactive" style="--edge-color:${accent.color}; --glow-color:${accent.glow};">
              <div class="flex items-center gap-3">
                <div class="w-12 h-12 flex items-center justify-center rounded-xl device-rim-icon" data-depth="0.7">
                  <span class="material-symbols-outlined" style="color:${accent.color};">router</span>
                </div>
                <div class="flex-1 min-w-0">
                  <div class="flex items-start justify-between gap-2">
                    <div class="min-w-0">
                      <h3 class="text-base sm:text-lg uppercase tracking-[0.12em] truncate font-black" style="font-family:'Orbitron',sans-serif;color:#ff7cea;text-shadow:0 0 8px rgba(255,51,223,0.35);">${ssid}</h3>
                      <p class="text-[10px] uppercase tracking-[0.19em] mt-1" style="color:rgba(250,255,0,0.78);">IP: -- // MAC: ${bssid}</p>
                      <p class="text-[10px] uppercase tracking-[0.17em] mt-1" style="color:rgba(106,236,255,0.72);">VENDOR: ${security} // ${freq}</p>
                    </div>
                    <div class="shrink-0 text-right">
                      <span class="text-[9px] font-black tracking-[0.3em] px-2 py-1 rounded-full border" style="font-family:'Orbitron',sans-serif;color:${accent.color}; border-color:${accent.color};">${badge}</span>
                      <div class="mt-2 w-20">
                        <div class="text-[8px] tracking-[0.28em] uppercase mb-1" style="font-family:'Orbitron',sans-serif;color:#b7ff00;">LATENCY</div>
                        <div class="holo-meter-track"><div class="holo-meter-fill" style="width:${meterPct}%; --edge-color:${accent.color};"></div></div>
                        <div class="text-[9px] mt-1 font-mono" style="color:${accent.color};">${latency} ms</div>
                      </div>
                    </div>
                  </div>
                  <div class="mt-3 flex items-center justify-between gap-3">
                    <div class="relative h-2.5 w-full liquid-bar-container">
                      <div class="liquid-bar-fill" style="width:${signalPct}%; --bar-start:${accent.color}; --bar-mid:${accent.color}; --bar-end:#ffffff;"></div>
                    </div>
                    <div class="flex items-center gap-2 whitespace-nowrap">
                      ${active ? '<span class="signal-pulse" aria-label="active-device"></span>' : '<span class="size-2 rounded-full bg-ethereal-blue/30"></span>'}
                      <span class="text-[10px] font-bold tracking-[0.16em]" style="color:${accent.color};">${level}</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          `;
        }).join("");
        renderMapFromScan();
      }

      function formatScanTime(epochMs) {
        if (!epochMs) return "Never";
        try {
          return new Date(epochMs).toLocaleTimeString();
        } catch {
          return "Unknown";
        }
      }

      function mapPositionFor(index, total) {
        const safeTotal = Math.max(1, total);
        const angle = (Math.PI * 2 * index) / safeTotal;
        const ring = 130 + ((index % 6) * 26);
        return {
          angle,
          ring,
          depthSeed: ((index * 37) % 100) / 100,
        };
      }

      function filteredMapNetworks() {
        const query = runtime.mapFilterText.trim().toLowerCase();
        if (!query) return runtime.lastScanResults;
        return runtime.lastScanResults.filter((network) => {
          const ssid = String(network.ssid || "").toLowerCase();
          const bssid = String(network.bssid || "").toLowerCase();
          return ssid.includes(query) || bssid.includes(query);
        });
      }

      function updateMapStatus(networks) {
        const live = runtime.lastScanSource !== "none";
        const scanLabel = runtime.mapScanInProgress
          ? "SCANNING LIVE TOPOLOGY"
          : live
            ? `${runtime.lastScanSource.toUpperCase()} SCAN ACTIVE`
            : "Awaiting Live Scan";
        nativeUi.mapActiveNodes.textContent = `${networks.length}`;
        nativeUi.mapValue.textContent = `${networks.length}`;
        nativeUi.mapLastSync.textContent = formatScanTime(runtime.lastScanCapturedAt);
        nativeUi.mapScanStatus.textContent = scanLabel;
        nativeUi.mapAlertText.innerHTML = live
          ? `Nodes Loaded: ${networks.length}<br/>Last Sync: ${escapeHtml(formatScanTime(runtime.lastScanCapturedAt))}<br/>Source: ${escapeHtml(runtime.lastScanSource.toUpperCase())}`
          : "Trigger Scan To Populate<br/>Last Sync: Never<br/>Source: Native Bridge";
      }

      function createHoloMapRenderer() {
        const viewport = nativeUi.holoMapViewport;
        const canvas = nativeUi.holoMapCanvas;
        if (!viewport || !canvas) {
          return {
            sync() {},
            setScanState() {},
            setCloakState() {},
            destroy() {},
          };
        }
        const ctx = canvas.getContext("2d", { alpha: true });
        if (!ctx) {
          return {
            sync() {},
            setScanState() {},
            setCloakState() {},
            destroy() {},
          };
        }

        const mapState = {
          hoveredIndex: -1,
          selectedIndex: -1,
          pointerId: null,
          dragging: false,
          dragStartX: 0,
          dragStartY: 0,
          dragMove: 0,
          panX: 0,
          panY: 0,
          targetPanX: 0,
          targetPanY: 0,
          zoom: 1,
          targetZoom: 1,
          cameraX: 0,
          cameraY: 0,
          targetCameraX: 0,
          targetCameraY: 0,
          scanWaveRadius: 0,
          scanWavePulse: 0,
          discoverAt: new Map(),
          nodes: [],
          lastWidth: 0,
          lastHeight: 0,
        };

        let rafId = 0;
        let lastTs = performance.now();

        const resize = () => {
          const rect = viewport.getBoundingClientRect();
          const ratio = Math.min(window.devicePixelRatio || 1, 2);
          canvas.width = Math.max(1, Math.floor(rect.width * ratio));
          canvas.height = Math.max(1, Math.floor(rect.height * ratio));
          canvas.style.width = `${rect.width}px`;
          canvas.style.height = `${rect.height}px`;
          ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
          mapState.lastWidth = rect.width;
          mapState.lastHeight = rect.height;
        };

        const toScreenPoint = (node, timeMs) => {
          const cX = mapState.lastWidth * 0.5 + mapState.panX;
          const cY = mapState.lastHeight * 0.5 + mapState.panY;
          const t = timeMs * 0.001;
          const orbitSpeed = runtime.mapScanInProgress ? 0.65 : 0.22;
          const orbitAngle = node.angle + t * orbitSpeed + (node.index * 0.07);
          const bob = Math.sin(t * 1.7 + node.index) * 7;
          const x = cX + Math.cos(orbitAngle) * node.ring * mapState.zoom;
          const y = cY + Math.sin(orbitAngle) * node.ring * 0.62 * mapState.zoom + bob;
          const zRaw = Math.sin(orbitAngle * 0.85 + node.depthSeed * Math.PI * 2);
          const z = zRaw * 0.85;
          const scale = 0.72 + ((z + 1) * 0.42);
          return { x, y, z, scale };
        };

        const pickNodeAt = (x, y, timeMs) => {
          let hit = -1;
          let hitDepth = -Infinity;
          for (const node of mapState.nodes) {
            const screen = toScreenPoint(node, timeMs);
            const radius = 8 + screen.scale * 7;
            const dx = x - screen.x;
            const dy = y - screen.y;
            if ((dx * dx) + (dy * dy) <= radius * radius && screen.z >= hitDepth) {
              hit = node.index;
              hitDepth = screen.z;
            }
          }
          return hit;
        };

        const setTooltip = (clientX, clientY, node) => {
          if (!nativeUi.holoMapTooltip || !node) return;
          nativeUi.holoMapTooltip.innerHTML = `${escapeHtml(node.network.ssid || `Hidden-${node.index + 1}`)}<br/><span style="opacity:.65">${escapeHtml(node.network.bssid || "N/A")}</span>`;
          const rect = viewport.getBoundingClientRect();
          nativeUi.holoMapTooltip.style.left = `${clientX - rect.left}px`;
          nativeUi.holoMapTooltip.style.top = `${clientY - rect.top}px`;
          nativeUi.holoMapTooltip.classList.add("is-visible");
        };

        const hideTooltip = () => {
          nativeUi.holoMapTooltip?.classList.remove("is-visible");
        };

        const animate = (ts) => {
          const dt = Math.min(48, ts - lastTs);
          lastTs = ts;
          mapState.panX += (mapState.targetPanX - mapState.panX) * 0.14;
          mapState.panY += (mapState.targetPanY - mapState.panY) * 0.14;
          mapState.zoom += (mapState.targetZoom - mapState.zoom) * 0.15;
          mapState.cameraX += (mapState.targetCameraX - mapState.cameraX) * 0.07;
          mapState.cameraY += (mapState.targetCameraY - mapState.cameraY) * 0.07;
          if (runtime.mapScanInProgress) {
            mapState.scanWaveRadius += dt * 0.22;
            if (mapState.scanWaveRadius > Math.max(mapState.lastWidth, mapState.lastHeight) * 0.7) {
              mapState.scanWaveRadius = 0;
            }
            mapState.scanWavePulse += dt * 0.005;
          }

          ctx.clearRect(0, 0, mapState.lastWidth, mapState.lastHeight);
          const centerX = (mapState.lastWidth * 0.5) + mapState.panX + mapState.cameraX;
          const centerY = (mapState.lastHeight * 0.5) + mapState.panY + mapState.cameraY;

          const radial = ctx.createRadialGradient(centerX, centerY, 18, centerX, centerY, Math.max(mapState.lastWidth, mapState.lastHeight) * 0.75);
          radial.addColorStop(0, "rgba(0,220,255,0.12)");
          radial.addColorStop(0.5, "rgba(5,23,43,0.22)");
          radial.addColorStop(1, "rgba(0,0,0,0.92)");
          ctx.fillStyle = radial;
          ctx.fillRect(0, 0, mapState.lastWidth, mapState.lastHeight);

          ctx.save();
          ctx.translate(centerX, centerY);
          for (let ring = 1; ring <= 4; ring += 1) {
            ctx.strokeStyle = `rgba(0,212,255,${0.06 + ring * 0.04})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(0, 0, ring * 68 * mapState.zoom, ring * 42 * mapState.zoom, 0, 0, Math.PI * 2);
            ctx.stroke();
          }
          if (runtime.mapScanInProgress) {
            const wave = mapState.scanWaveRadius;
            ctx.strokeStyle = `rgba(250,255,0,${0.14 + Math.sin(mapState.scanWavePulse) * 0.08})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(0, 0, wave, wave * 0.58, 0, 0, Math.PI * 2);
            ctx.stroke();
          }
          ctx.restore();

          const screenNodes = mapState.nodes.map((node) => ({ node, screen: toScreenPoint(node, ts) }));
          screenNodes.sort((a, b) => a.screen.z - b.screen.z);

          for (let i = 0; i < screenNodes.length; i += 1) {
            const curr = screenNodes[i];
            const next = screenNodes[(i + 1) % screenNodes.length];
            if (!next || screenNodes.length < 2) break;
            const isHot = curr.node.index === mapState.hoveredIndex || next.node.index === mapState.hoveredIndex;
            const glow = isHot ? "rgba(250,255,0,0.52)" : "rgba(0,212,255,0.24)";
            ctx.strokeStyle = glow;
            ctx.lineWidth = isHot ? 2.2 : 1.1;
            ctx.globalAlpha = 0.2 + ((curr.screen.scale + next.screen.scale) * 0.18);
            ctx.beginPath();
            ctx.moveTo(curr.screen.x + mapState.cameraX * curr.screen.scale * 0.2, curr.screen.y + mapState.cameraY * curr.screen.scale * 0.2);
            ctx.lineTo(next.screen.x + mapState.cameraX * next.screen.scale * 0.2, next.screen.y + mapState.cameraY * next.screen.scale * 0.2);
            ctx.stroke();

            if (runtime.mapScanInProgress || runtime.lastScanSource !== "none") {
              const p = ((ts * 0.0004) + (i * 0.13)) % 1;
              const px = curr.screen.x + ((next.screen.x - curr.screen.x) * p);
              const py = curr.screen.y + ((next.screen.y - curr.screen.y) * p);
              ctx.fillStyle = isHot ? "rgba(250,255,0,0.95)" : "rgba(0,243,255,0.8)";
              ctx.shadowColor = ctx.fillStyle;
              ctx.shadowBlur = 12;
              ctx.beginPath();
              ctx.arc(px, py, 1.7 + (isHot ? 1.2 : 0), 0, Math.PI * 2);
              ctx.fill();
              ctx.shadowBlur = 0;
            }
          }

          const coreGlow = 20 + (Math.sin(ts * 0.004) * 3);
          ctx.fillStyle = "rgba(12,28,42,0.9)";
          ctx.beginPath();
          ctx.arc(centerX, centerY, 22, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "rgba(0,243,255,0.7)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(centerX, centerY, coreGlow, 0, Math.PI * 2);
          ctx.stroke();
          ctx.fillStyle = "rgba(250,255,0,0.95)";
          ctx.beginPath();
          ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
          ctx.fill();

          for (const entry of screenNodes) {
            const { node, screen } = entry;
            const accent = node.accent;
            const isHover = node.index === mapState.hoveredIndex;
            const isSelected = node.index === mapState.selectedIndex;
            const discoveredAt = mapState.discoverAt.get(node.key) || ts;
            const discoverPhase = Math.min(1, (ts - discoveredAt) / 520);
            const materializeScale = runtime.mapScanInProgress ? discoverPhase : 1;
            const opacity = (0.24 + ((screen.z + 1) * 0.34)) * (runtime.mapCloakEnabled ? 0.45 : 1);
            const radius = (3.8 + screen.scale * 4.4) * materializeScale * (isSelected ? 1.2 : 1);
            const drawX = screen.x + mapState.cameraX * screen.scale * 0.35;
            const drawY = screen.y + mapState.cameraY * screen.scale * 0.35;

            ctx.globalAlpha = opacity;
            ctx.filter = `blur(${Math.max(0, (1 - screen.scale) * 2.2).toFixed(2)}px)`;
            ctx.fillStyle = accent.color;
            ctx.beginPath();
            ctx.arc(drawX, drawY, radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.filter = "none";
            ctx.globalAlpha = isHover || isSelected ? 1 : Math.min(1, opacity + 0.26);
            ctx.strokeStyle = isHover ? "#b7ff00" : accent.color;
            ctx.lineWidth = isHover ? 2.4 : 1.1;
            ctx.beginPath();
            ctx.arc(drawX, drawY, radius + (isHover ? 4 : 2), 0, Math.PI * 2);
            ctx.stroke();

            if (isHover || isSelected || screen.scale > 1.12) {
              ctx.globalAlpha = Math.min(0.9, opacity + 0.2);
              ctx.fillStyle = "rgba(206,248,255,0.88)";
              ctx.font = "10px Orbitron, sans-serif";
              ctx.textAlign = "center";
              ctx.fillText(node.label, drawX, drawY - 12 - (radius * 0.6));
            }
            ctx.globalAlpha = 1;
          }

          rafId = requestAnimationFrame(animate);
        };

        const onPointerMove = (event) => {
          const rect = viewport.getBoundingClientRect();
          const localX = event.clientX - rect.left;
          const localY = event.clientY - rect.top;
          if (mapState.dragging && mapState.pointerId === event.pointerId) {
            const dx = event.clientX - mapState.dragStartX;
            const dy = event.clientY - mapState.dragStartY;
            mapState.dragMove += Math.abs(dx) + Math.abs(dy);
            mapState.targetPanX += dx;
            mapState.targetPanY += dy;
            mapState.dragStartX = event.clientX;
            mapState.dragStartY = event.clientY;
          }
          mapState.targetCameraX = ((localX / Math.max(1, rect.width)) - 0.5) * 22;
          mapState.targetCameraY = ((localY / Math.max(1, rect.height)) - 0.5) * 22;
          const hover = pickNodeAt(localX, localY, performance.now());
          mapState.hoveredIndex = hover;
          if (hover >= 0) {
            const node = mapState.nodes.find((item) => item.index === hover);
            setTooltip(event.clientX, event.clientY, node);
          } else {
            hideTooltip();
          }
        };

        const onPointerDown = (event) => {
          mapState.pointerId = event.pointerId;
          mapState.dragging = true;
          mapState.dragMove = 0;
          mapState.dragStartX = event.clientX;
          mapState.dragStartY = event.clientY;
          viewport.classList.add("is-panning");
          viewport.setPointerCapture(event.pointerId);
        };

        const onPointerUp = (event) => {
          if (mapState.dragging && mapState.pointerId === event.pointerId && mapState.dragMove < 8) {
            const rect = viewport.getBoundingClientRect();
            const hit = pickNodeAt(event.clientX - rect.left, event.clientY - rect.top, performance.now());
            if (hit >= 0) {
              mapState.selectedIndex = hit;
              const selected = mapState.nodes.find((node) => node.index === hit);
              if (selected) {
                showCfgStatus(`Node selected: ${selected.network.ssid || selected.network.bssid || `Node ${hit + 1}`}`);
                nativeUi.mapAlertText.innerHTML = `Selected: ${escapeHtml(selected.network.ssid || `Hidden-${hit + 1}`)}<br/>BSSID: ${escapeHtml(selected.network.bssid || "N/A")}<br/>Signal: ${escapeHtml(`${selected.network.signalLevel ?? "--"} dBm`)}`;
              }
            }
          }
          mapState.dragging = false;
          mapState.pointerId = null;
          viewport.classList.remove("is-panning");
          hideTooltip();
        };

        const onPointerLeave = () => {
          mapState.hoveredIndex = -1;
          mapState.targetCameraX = 0;
          mapState.targetCameraY = 0;
          hideTooltip();
        };

        const onWheel = (event) => {
          event.preventDefault();
          const dir = event.deltaY > 0 ? -0.08 : 0.08;
          mapState.targetZoom = clamp(mapState.targetZoom + dir, 0.65, 1.55);
        };

        const onTilt = (event) => {
          const gamma = Number(event.gamma || 0);
          const beta = Number(event.beta || 0);
          if (Number.isNaN(gamma) || Number.isNaN(beta)) return;
          mapState.targetCameraX = clamp(gamma * 0.25, -18, 18);
          mapState.targetCameraY = clamp(beta * 0.12, -18, 18);
        };

        viewport.addEventListener("pointerdown", onPointerDown);
        viewport.addEventListener("pointermove", onPointerMove);
        viewport.addEventListener("pointerup", onPointerUp);
        viewport.addEventListener("pointercancel", onPointerUp);
        viewport.addEventListener("pointerleave", onPointerLeave);
        viewport.addEventListener("wheel", onWheel, { passive: false });
        window.addEventListener("resize", resize);
        window.addEventListener("deviceorientation", onTilt);

        resize();
        rafId = requestAnimationFrame(animate);

        return {
          sync(networks) {
            const now = performance.now();
            const nextKeys = new Set();
            mapState.nodes = networks.map((network, index) => {
              const key = network.bssid || network.ssid || `node-${index}`;
              nextKeys.add(key);
              if (!mapState.discoverAt.has(key)) {
                mapState.discoverAt.set(key, now);
              }
              const layout = mapPositionFor(index, networks.length);
              return {
                key,
                index,
                network,
                accent: signalAccent(Number(network.signalLevel ?? -90)),
                angle: layout.angle,
                ring: layout.ring,
                depthSeed: layout.depthSeed,
                label: String(network.ssid || `Node_${index + 1}`).slice(0, 18),
              };
            });
            for (const key of [...mapState.discoverAt.keys()]) {
              if (!nextKeys.has(key)) {
                mapState.discoverAt.delete(key);
              }
            }
            if (mapState.selectedIndex >= mapState.nodes.length) {
              mapState.selectedIndex = -1;
            }
          },
          setScanState(scanning) {
            if (scanning) {
              mapState.scanWaveRadius = 0;
              mapState.scanWavePulse = 0;
            }
          },
          setCloakState(enabled) {
            canvas.style.opacity = enabled ? "0.58" : "1";
          },
          destroy() {
            cancelAnimationFrame(rafId);
            viewport.removeEventListener("pointerdown", onPointerDown);
            viewport.removeEventListener("pointermove", onPointerMove);
            viewport.removeEventListener("pointerup", onPointerUp);
            viewport.removeEventListener("pointercancel", onPointerUp);
            viewport.removeEventListener("pointerleave", onPointerLeave);
            viewport.removeEventListener("wheel", onWheel);
            window.removeEventListener("resize", resize);
            window.removeEventListener("deviceorientation", onTilt);
          },
        };
      }

      const holoMapRenderer = createHoloMapRenderer();

      function renderMapFromScan() {
        const networks = filteredMapNetworks();
        updateMapStatus(networks);
        holoMapRenderer.sync(networks);

        nativeUi.mapNodesList.innerHTML = networks.slice(0, 6).map((network, index) => {
          const accent = signalAccent(Number(network.signalLevel ?? -90));
          const ssid = escapeHtml(network.ssid || `Hidden-${index + 1}`);
          const sec = escapeHtml(formatSecurity(network.capabilities));
          const freq = escapeHtml(network.frequency ? `${network.frequency} MHz` : "Unknown band");
          return `
            <div class="relative group holo-interactive">
              <div class="bg-engine-iron/80 border rounded p-3 aspect-video flex flex-col justify-between overflow-hidden relative holo-bloom" style="border-color:${accent.color}66; box-shadow:0 0 12px ${accent.glow};">
                <div class="absolute inset-0 opacity-10" style="background:${accent.color};"></div>
                <div class="flex justify-between items-start">
                  <span class="text-[10px] font-mono uppercase" style="color:${accent.color};">Node_${index + 1}</span>
                  <span class="material-symbols-outlined text-xs text-cyber-violet">wifi</span>
                </div>
                <p class="text-ethereal-blue text-[11px] font-bold leading-none tracking-tight truncate">${ssid}</p>
                <p class="text-[9px] text-slate-400 font-mono">${freq} // ${sec}</p>
              </div>
            </div>
          `;
        }).join("");
      }

      function syncBridgeState(pushConfigToggle) {
        const bridgeState = nativeBridge.call("getBridgeState");
        runtime.bridgeState = bridgeState || runtime.bridgeState;
        if (pushConfigToggle && bridgeState) {
          cfgCtrls.bridgeEnabled.checked = !!bridgeState.enabled;
        }
        updateBridgeUi();
      }

      function refreshDeviceInfo() {
        const result = nativeBridge.call("getDeviceInfo");
        if (result?.ok && result.deviceInfo) {
          runtime.lastDeviceInfo = result.deviceInfo;
          updateDeviceUi();
          return true;
        }
        runtime.lastDeviceInfo = null;
        updateDeviceUi();
        return false;
      }

      function loadConfig() {
        const raw = localStorage.getItem(cfgKey);
        let data = defaultConfig();
        if (raw) {
          try {
            data = { ...data, ...JSON.parse(raw) };
          } catch {}
        }
        setConfigControls(data);
        applyPerfMode(cfgCtrls.perfMode.value);
      }

      function saveConfig() {
        const data = getCurrentConfig();
        localStorage.setItem(cfgKey, JSON.stringify(data));
        applyPerfMode(data.perfMode);
        if (nativeBridge.available()) {
          const bridgeState = nativeBridge.call("setBridgeEnabled", !!data.bridgeEnabled);
          if (bridgeState) {
            runtime.bridgeState = bridgeState;
          }
        }
        syncBridgeState(false);
        if (runtime.bridgeState.enabled) {
          refreshDeviceInfo();
        } else {
          runtime.lastDeviceInfo = null;
          updateDeviceUi();
        }
        if (runtime.lastScanResults.length > 0) {
          renderMapFromScan();
        }
        showCfgStatus("Settings saved.");
      }

      function resetConfig() {
        localStorage.removeItem(cfgKey);
        const defaults = defaultConfig();
        setConfigControls(defaults);
        applyPerfMode(defaults.perfMode);
        if (nativeBridge.available()) {
          const bridgeState = nativeBridge.call("setBridgeEnabled", false);
          if (bridgeState) {
            runtime.bridgeState = bridgeState;
          }
        }
        runtime.lastDeviceInfo = null;
        updateDeviceUi();
        syncBridgeState(false);
        renderWifiNetworks([], "none", "Waiting for live scan data");
        showCfgStatus("Settings reset.");
      }

      function applyPerfMode(mode) {
        const overlay = document.querySelector(".vhs-overlay");
        const buttons = document.querySelectorAll(".cybr-btn");
        if (mode === "low") {
          overlay.style.opacity = "0.15";
          buttons.forEach(btn => {
            btn.classList.remove("tap-glow");
            btn.classList.add("tap-glow-low");
          });
        } else {
          overlay.style.opacity = "0.30";
          buttons.forEach(btn => {
            btn.classList.remove("tap-glow-low");
            btn.classList.add("tap-glow");
          });
        }
      }

      function exportDiagnostics() {
        syncBridgeState(false);
        if (!runtime.bridgeState.available || !runtime.bridgeState.enabled) {
          showCfgStatus("Enable Native Bridge before exporting diagnostics.");
          return;
        }
        const payload = {
          capturedAt: new Date().toISOString(),
          config: getCurrentConfig(),
          lastScan: {
            source: runtime.lastScanSource,
            count: runtime.lastScanResults.length,
            results: runtime.lastScanResults,
          },
          engine: {
            state,
            latency: ui.latencyVal.textContent,
            jitter: ui.jitterVal.textContent,
            loss: ui.lossVal.textContent,
            down: ui.downVal.textContent,
            up: ui.upVal.textContent,
          },
        };
        const result = nativeBridge.call("exportDiagnostics", JSON.stringify(payload));
        if (result?.ok === false) {
          showCfgStatus(result.message || "Diagnostics export failed.");
        } else {
          nativeUi.wifiScanState.textContent = "Export Requested";
        }
      }

      function requestNativeWifiScan(userInitiated) {
        syncBridgeState(false);
        if (!runtime.bridgeState.available || !runtime.bridgeState.enabled) {
          if (userInitiated) {
            showCfgStatus("Enable Native Bridge first.");
          }
          return;
        }
        if (!userInitiated && !runtime.bridgeState.scanPermissionGranted) {
          nativeUi.wifiScanState.textContent = "Tap Scan To Grant";
          nativeUi.wifiScanMeta.textContent = "Auto scan paused until permissions are granted";
          updateWifiListState(runtime.lastScanResults, runtime.lastScanSource, nativeUi.wifiScanMeta.textContent);
          return;
        }
        const result = nativeBridge.call("requestWifiScan");
        if (result?.ok === false) {
          nativeUi.wifiScanState.textContent = result.code || "Error";
          if (userInitiated) {
            showCfgStatus(result.message || "Wi-Fi scan failed.");
          }
        } else if (result?.status === "permission_requested") {
          nativeUi.wifiScanState.textContent = "Permission Requested";
          nativeUi.wifiScanMeta.textContent = "Grant permissions to continue live scanning";
          updateWifiListState(runtime.lastScanResults, runtime.lastScanSource, nativeUi.wifiScanMeta.textContent);
        } else {
          runtime.mapScanInProgress = true;
          holoMapRenderer.setScanState(true);
          nativeUi.wifiScanState.textContent = "Scanning";
          nativeUi.wifiScanMeta.textContent = "Native scan request sent to Android";
          updateWifiListState(runtime.lastScanResults, runtime.lastScanSource, nativeUi.wifiScanMeta.textContent);
          renderMapFromScan();
        }
      }

      function handleNativeEvent(event) {
        const detail = event.detail || {};
        const payload = detail.payload || {};
        if (detail.type === "bridge_state") {
          runtime.bridgeState = payload;
          updateBridgeUi();
          if (payload.enabled) {
            refreshDeviceInfo();
          }
          return;
        }
        if (detail.type === "wifi_scan_results") {
          runtime.mapScanInProgress = false;
          const results = Array.isArray(payload.results) ? payload.results : [];
          runtime.lastScanCapturedAt = Number(payload.capturedAt || Date.now());
          if (results.length > 0) {
            renderWifiNetworks(results, payload.source || "real", `${payload.count || results.length} networks captured`);
            nativeUi.wifiScanState.textContent = payload.source === "cached" ? "Cached Results" : "Live Results";
          } else {
            renderWifiNetworks([], payload.source || "real", "No nearby networks found");
            nativeUi.wifiScanState.textContent = "No Results";
          }
          return;
        }
        if (detail.type === "scan_status") {
          const status = payload.status || "idle";
          runtime.mapScanInProgress = ["started", "scanning", "in_progress"].includes(status);
          if (!runtime.mapScanInProgress) {
            holoMapRenderer.setScanState(false);
          }
          nativeUi.wifiScanState.textContent = status.replaceAll("_", " ").toUpperCase();
          if (payload.message) {
            nativeUi.wifiScanMeta.textContent = payload.message;
            updateWifiListState(runtime.lastScanResults, runtime.lastScanSource, nativeUi.wifiScanMeta.textContent);
          }
          return;
        }
        if (detail.type === "export_status") {
          if (payload.status === "saved") showCfgStatus("Diagnostics exported.");
          else if (payload.status === "cancelled") showCfgStatus("Diagnostics export cancelled.");
          else if (payload.status === "error") showCfgStatus(payload.message || "Diagnostics export failed.");
        }
      }

      function onListTabSelected() {
        syncBridgeState(false);
        if (cfgCtrls.autoScan.checked && runtime.bridgeState.enabled && runtime.bridgeState.scanPermissionGranted) {
          requestNativeWifiScan(false);
          return;
        }
        if (runtime.lastScanResults.length === 0) {
          nativeUi.wifiScanMeta.textContent = "Waiting for live scan data";
          updateWifiListState(runtime.lastScanResults, runtime.lastScanSource, nativeUi.wifiScanMeta.textContent);
        }
      }

      nativeUi.mapSearchInput?.addEventListener("input", (event) => {
        runtime.mapFilterText = String(event.target?.value || "");
        renderMapFromScan();
      });

      nativeUi.mapOverdriveBtn?.addEventListener("click", () => {
        runtime.mapOverdriveEnabled = !runtime.mapOverdriveEnabled;
        nativeUi.mapOverdriveBtn.classList.toggle("bg-cyber-violet/20", !runtime.mapOverdriveEnabled);
        nativeUi.mapOverdriveBtn.classList.toggle("bg-ethereal-blue/25", runtime.mapOverdriveEnabled);
        showCfgStatus(runtime.mapOverdriveEnabled ? "Map Overdrive enabled." : "Map Overdrive disabled.");
      });

      nativeUi.mapCloakBtn?.addEventListener("click", () => {
        runtime.mapCloakEnabled = !runtime.mapCloakEnabled;
        nativeUi.mapCloakBtn.classList.toggle("opacity-55", runtime.mapCloakEnabled);
        holoMapRenderer.setCloakState(runtime.mapCloakEnabled);
        showCfgStatus(runtime.mapCloakEnabled ? "Map Cloak enabled." : "Map Cloak disabled.");
      });

      window.addEventListener(NATIVE_EVENT, handleNativeEvent);
      cfgSaveBtn?.addEventListener("click", saveConfig);
      cfgResetBtn?.addEventListener("click", resetConfig);
      nativeUi.wifiScanBtn?.addEventListener("click", () => requestNativeWifiScan(true));
      nativeUi.wifiExportBtn?.addEventListener("click", exportDiagnostics);
      nativeUi.cfgRefreshDeviceBtn?.addEventListener("click", () => {
        syncBridgeState(false);
        if (!runtime.bridgeState.enabled) {
          showCfgStatus("Enable Native Bridge before requesting device info.");
          return;
        }
        if (refreshDeviceInfo()) showCfgStatus("Device snapshot refreshed.");
        else showCfgStatus("Device snapshot unavailable.");
      });
      nativeUi.cfgExportDiagBtn?.addEventListener("click", exportDiagnostics);
      loadConfig();
      syncBridgeState(true);
      updateDeviceUi();
      const initialScan = nativeBridge.call("getLastWifiScan");
      if (initialScan?.ok && initialScan.scan) {
        const scan = initialScan.scan;
        runtime.lastScanCapturedAt = Number(scan.capturedAt || 0);
        renderWifiNetworks(Array.isArray(scan.results) ? scan.results : [], scan.source || "none", "Restored last native scan snapshot");
      } else {
        renderWifiNetworks([], "none", "Waiting for live scan data");
      }
      resetUI();
    })();
  </script>
</body>
</html>
